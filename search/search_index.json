{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"polycomp","text":"<p>Python implementation of polymer field theory with an emphasis on flexibility,  accessibility, and speed. </p> <p>Our current development has placed an emphasis on simulations  of charged linear polymers, but the platform is flexible and we plan to continue  development on many systems. The code runs only on GPUs due to the computational cost of the simulations.  </p>"},{"location":"examples/","title":"Examples","text":"<p>Here is a sample file that will generate a diblock copolymer melt. </p> <pre><code>from celluloid import Camera\nimport cupy as cp\nimport matplotlib.pyplot as plt\nimport polycomp.ft_system as p\nfrom polycomp.observables import * \nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\n#Set a seed for reproducibility (or turn off for full randomization)\ncp.random.seed(0)\n\n#Declare all of your polymers with their name and charge\nA_mon = p.Monomer(\"A\", 0)\nB_mon = p.Monomer(\"B\", 0)\n\n#Declare a list of all the monomer types in the simulation\n#(Salts are handled automatically if needed)\nmonomers = [A_mon, B_mon]\n\ntot = 130\ndiff = 15.2\n\n#Declare a Flory-Huggins array with each cross iteraction\n#Here we use total and difference to simplify the description\nFH_terms = {\n        frozenset({A_mon}) : tot, \n        frozenset({B_mon}) : tot, \n        frozenset({A_mon, B_mon}) : tot + diff, \n        }\n\n#Declare the reference polymer length for the system. In this case it will be the\n# same as the length of the only polymer in solution \nN = 5\n\n#Declare all the polymer types in solution. In this case we have a single \"AB\" diblock\n# copolymer that is half A and half B, with a total length of N. \nAB_poly = p.Polymer(\"AB\", N, [(A_mon, 0.5), (B_mon, 0.5)])\n\n#Declare a list of all the polymers in simulation \npolymers = [AB_poly]\n\n#Declare a dictionary with all the species in the system (this will include polymers\n# and solvents, but here we just have one polymer). We also declare the concentration\n# of each species, in this case just 1. \nspec_dict = {\n        AB_poly : 1.,\n        }\n#Declare the number of grid points across each axis. This will be a 2D simulation \n# with 256 grid points along each dimension. \ngrid_spec = (256,256)\n\n#Declare the side length of the box along each axis. Here we have 25x25 length square.\nbox_length = (25,25)\n\n#Declare the grid object as specified using our parameterss.\ngrid = p.Grid(box_length=box_length, grid_spec = grid_spec)\n\n#Declare the smearing length for the charge and density\nsmear = 0.2\n\n#We can now declare the full polymer system. Read the full documentation for details, \n# but we use previously declared variables and specify salt concentration and \n# integration fineness along the polymer. \nps = p.PolymerSystem(monomers, polymers, spec_dict, FH_terms,\n        grid, smear, salt_conc=0.0 * N, integration_width = 1/20)\n\n#Now we move to our integration parameters. We need a timestep associated with each \n# field, but they'll all be the same here. \nrelax_rates = cp.array([0.45]*(ps.w_all.shape[0]))\n\n#We also declare a temperature array which is the same shape\ntemps = cp.array([0.001 + 0j]*(ps.w_all.shape[0]))\n\n#This temperature corresponds to using the \"standard\" CL integrator, but other versions\n# generally are valid\ntemps *= ps.gamma.real\n\n#Because this is an uncharged system, we set E to 0, and set all the electric field \n# rates to 0 as well\nE = 0\npsi_rate = 0\npsi_temp = 0\n\n#Now we actually declare the integrator\nintegrator = p.CL_RK2(ps, relax_rates, temps, psi_rate, psi_temp, E)\n\n#These are all plotting parameters and will need to be changed if we want more or less \n# plots\nnrows=1\nncols=3\nfig, axes = plt.subplots(nrows=nrows, ncols=ncols, dpi=170, figsize=(6,2))\nfig.suptitle('Example of simple microphase separation')\nmulti_cam = Camera(fig)\n\n#generate an initial density for the starting plot\nps.get_densities()\n\nim = []\ndiv = []\ncax = [] \ncb = [] \nfor i in range(nrows):\n    im.append([0] * ncols)\n    div.append([0] * ncols)\n    cax.append([0] * ncols)\n    cb.append([0] * ncols)\n\n#Initial plots\nim[0][0] = axes[0].imshow(ps.phi_all[ps.monomers.index(A_mon)].real.get(), cmap = 'Blues')\naxes[0].set_title('A Dens')\nim[0][1] = axes[1].imshow(ps.phi_all[ps.monomers.index(B_mon)].real.get(), cmap = 'Reds')\naxes[1].set_title('B Dens')\nim[0][2] = axes[2].imshow(cp.sum(ps.phi_all, axis=0).real.get(), cmap = 'Greys')\naxes[2].set_title('Total density')\n\n#Declare some empty arrays to store our variables\ndens_traj = []\nfree_energy_traj = []\n\n#Set the number of steps per frame\nsteps = 100\n\n#Set the number of arrays to capture\nfor i in range(30):\n\n    #We average over multiple views to reduce the noise for visualization, could just \n    # plot directly as well to simplify this\n    hold_A = cp.zeros_like(ps.phi_all[0].real)\n    hold_B = cp.zeros_like(ps.phi_all[0].real)\n    hold_T = cp.zeros_like(ps.phi_all[0].real)\n    for _ in range(steps):\n\n        #Collect the variables of interest every step and average over some of them\n        free_energy_traj.append(get_free_energy(ps, E))\n        integrator.ETD()\n        hold_A += ps.phi_all[ps.monomers.index(A_mon)].real / steps\n        hold_B += ps.phi_all[ps.monomers.index(B_mon)].real / steps\n        hold_T += cp.sum(ps.phi_all, axis=0).real / steps\n\n    #Save intermediate results here\n    cp.save('free_energy_traj', cp.array(free_energy_traj))\n    dens_traj.append((hold_A, hold_B, hold_T))\n\n    #Create new plots (use celluloid to make a simple animation)\n    im[0][0] = axes[0].imshow(hold_A.get(), cmap = 'Blues', vmin = 0)\n    im[0][1] = axes[1].imshow(hold_B.get(), cmap = 'Reds', vmin = 0)\n    im[0][2] = axes[2].imshow(hold_T.get(), cmap = 'Greys', vmin = 0)\n    multi_cam.snap()\n\n    #Save data needed to restart simulation\n    cp.save('midpoint', ps.w_all)\n    cp.save('psi_midpoint', ps.psi)\n    cp.save('live_dens_traj', cp.array(dens_traj))\n\n    #Print current progress\n    print(i)\n\n#Generate arrays from the lists for easier handling \ndens_traj = cp.array(dens_traj)\nfree_energy_traj = cp.array(free_energy_traj)\n\n#Save the full trajectories\ncp.save('dens_traj', dens_traj)\ncp.save('free_energy_traj', free_energy_traj)\n\n\n\n#The next section is all just to make relatively nice animations, mainly around \n# accurately handling color bar scales so the 2D plots are interpretable \nfor ax in axes.flat:\n    ax.set_xticks([])\n    ax.set_yticks([])\n\nfor i in range(nrows):\n    for j in range(ncols):\n        if im[i][j]==0:\n            continue\n        if nrows==1:\n            div[i][j] = make_axes_locatable(axes[j])\n        else:\n            div[i][j] = make_axes_locatable(axes[i,j])\n        cax[i][j] = div[i][j].append_axes('right', size='8%', pad=0.02)\nfor i in range(nrows):\n    for j in range(ncols):\n        cb[i][j] = fig.colorbar(im[i][j], cax=cax[i][j], orientation='vertical')\n        if im[i][j]==0:\n            continue\n        if nrows==1:\n            div[i][j] = make_axes_locatable(axes[j])\n        else:\n            div[i][j] = make_axes_locatable(axes[i,j])\n        cax[i][j] = div[i][j].append_axes('right', size='8%', pad=0.02)\n        cb[i][j].remove()\n        cb[i][j] = fig.colorbar(im[i][j], cax=cax[i][j], orientation='vertical')\n\n#Final plotting and saving the figures\nfig.tight_layout()\nmultimation = multi_cam.animate()\nmultimation.save('movie_traj.gif', writer='pillow')\nplt.show()\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>As the code is still under active development, it should be installed by downloading  from our github and installing locally via </p> <pre><code>pip install .\n</code></pre> <p>We look forward to building a conda package for easier installation in the near future. </p>"},{"location":"getting_started/#managing-dependencies","title":"Managing dependencies","text":"<p>You can find all of the required packages prepared in a single conda environment which can be installed via</p> <pre><code>conda env create --file polycomp.yml\n</code></pre> <p>The package will also require a working CUDA installation. </p>"},{"location":"getting_started/#running-the-tests","title":"Running the tests","text":"<p>You can make sure that your installation has worked by running </p> <pre><code>python tests.py\n</code></pre> <p>from the tests directory. </p> <p>You can also try try running some of the examples. </p>"},{"location":"grid/","title":"Grid","text":"<p>             Bases: <code>object</code></p> <p>Grid object for a polymer simulation.</p> <p>Attributes:</p> Name Type Description <code>grid_spec</code> <code>tuple</code> <p>Number of grid points along each axis.</p> <code>ndims</code> <code>int</code> <p>Dimension of the system.</p> <code>l</code> <code>cparray</code> <p>CPArray for the length of the box along each axis.</p> <code>dl</code> <code>cparray</code> <p>CPArray for the length of the box along each axis for the unit cell.</p> <code>V</code> <code>float</code> <p>Total box volume.</p> <code>dV</code> <code>float</code> <p>Volume of the unit cell.</p> <code>grid</code> <code>cparray</code> <p>Float array of the (x, ...) position at each grid point.</p> <code>kgrid</code> <code>cparray</code> <p>Complex grid of (x, ...) k Fourier-transformed positions at each k point.</p> <code>k1</code> <code>cparray</code> <p>Complex grid of (x, ...) L1 norm distances at each k point.</p> <code>k2</code> <code>cparray</code> <p>Complex grid of (x, ...) L2 norm distances at each k point.</p> Source code in <code>polycomp/grid.py</code> <pre><code>class Grid(object):\n    \"\"\"\n    Grid object for a polymer simulation.\n\n    Attributes:\n        grid_spec (tuple):\n            Number of grid points along each axis.\n        ndims (int):\n            Dimension of the system.\n        l (cparray):\n            CPArray for the length of the box along each axis.\n        dl (cparray):\n            CPArray for the length of the box along each axis for the unit cell.\n        V (float):\n            Total box volume.\n        dV (float):\n            Volume of the unit cell.\n        grid (cparray):\n            Float array of the (x, ...) position at each grid point.\n        kgrid (cparray):\n            Complex grid of (x, ...) k Fourier-transformed positions at each k point.\n        k1 (cparray):\n            Complex grid of (x, ...) L1 norm distances at each k point.\n        k2 (cparray):\n            Complex grid of (x, ...) L2 norm distances at each k point.\n    \"\"\"\n\n    def __init__(self, box_length, grid_spec):\n        \"\"\"\n        Initialize Grid\n\n        Builds grid object for given input values\n\n        Parameters:\n            box_length (tuple): tuple of floats representing the length of each axis of box\n            grid_spec (tuple): tuple of ints representing the number of grid points along each axis\n\n        Raises:\n\n            ValueError:\n                Raises error if the box length is not a tuple\n        \"\"\"\n        super(Grid, self).__init__()\n\n        self.grid_spec = grid_spec\n        self.ndims = len(self.grid_spec)\n        if type(box_length) is tuple:\n            self.l = cp.array(box_length)\n        else:\n            raise ValueError(\"box_length is not tuple\")\n        self.update_l(self.l)\n\n    def update_l(self, new_l):\n        \"\"\"\n        Set up everything inside the grid.\n\n        Builds various useful structures that provide information about the\n        grid, including Fourier-transformed positions and real position arrays.\n\n        Parameters:\n            new_l (tuple of float): Tuple of floats representing the new box lengths.\n\n        Raises:\n\n            ValueError: \n                Raises error if the box length is not a tuple\n        \"\"\"\n\n        self.l = cp.array(new_l)\n\n        # Total volume\n        self.V = cp.prod(cp.array(self.l))\n\n        # Grid of real positions\n        self.grid = cp.asarray(\n            cp.meshgrid(\n                *[\n                    cp.linspace(0, l, n)\n                    for n, l in zip(\n                        self.grid_spec,\n                        self.l * (1 - 1 / cp.array(self.grid_spec)),\n                    )\n                ]\n            )\n        )\n\n        # Grid of k positions\n        self.kgrid = cp.asarray(\n            cp.meshgrid(\n                *[\n                    2\n                    * cp.pi\n                    / l\n                    * cp.concatenate(\n                        (cp.arange(0, n / 2 + 1), cp.arange(-n / 2 + 1, 0)),\n                        axis=None,\n                    )\n                    for n, l in zip(self.grid_spec, self.l)\n                ]\n            )\n        )\n\n        self.k1 = cp.sum(self.kgrid, axis=0)\n        self.k2 = cp.sum(self.kgrid**2, axis=0)\n        self.dV = self.V / self.k2.size\n        self.dl = self.l / cp.array(self.grid_spec)\n\n        return\n</code></pre>"},{"location":"grid/#polycomp.grid.Grid.__init__","title":"<code>__init__(box_length, grid_spec)</code>","text":"<p>Initialize Grid</p> <p>Builds grid object for given input values</p> <p>Parameters:</p> Name Type Description Default <code>box_length</code> <code>tuple</code> <p>tuple of floats representing the length of each axis of box</p> required <code>grid_spec</code> <code>tuple</code> <p>tuple of ints representing the number of grid points along each axis</p> required <p>Raises:</p> <pre><code>ValueError:\n    Raises error if the box length is not a tuple\n</code></pre> Source code in <code>polycomp/grid.py</code> <pre><code>def __init__(self, box_length, grid_spec):\n    \"\"\"\n    Initialize Grid\n\n    Builds grid object for given input values\n\n    Parameters:\n        box_length (tuple): tuple of floats representing the length of each axis of box\n        grid_spec (tuple): tuple of ints representing the number of grid points along each axis\n\n    Raises:\n\n        ValueError:\n            Raises error if the box length is not a tuple\n    \"\"\"\n    super(Grid, self).__init__()\n\n    self.grid_spec = grid_spec\n    self.ndims = len(self.grid_spec)\n    if type(box_length) is tuple:\n        self.l = cp.array(box_length)\n    else:\n        raise ValueError(\"box_length is not tuple\")\n    self.update_l(self.l)\n</code></pre>"},{"location":"grid/#polycomp.grid.Grid.update_l","title":"<code>update_l(new_l)</code>","text":"<p>Set up everything inside the grid.</p> <p>Builds various useful structures that provide information about the grid, including Fourier-transformed positions and real position arrays.</p> <p>Parameters:</p> Name Type Description Default <code>new_l</code> <code>tuple of float</code> <p>Tuple of floats representing the new box lengths.</p> required <p>Raises:</p> <pre><code>ValueError: \n    Raises error if the box length is not a tuple\n</code></pre> Source code in <code>polycomp/grid.py</code> <pre><code>def update_l(self, new_l):\n    \"\"\"\n    Set up everything inside the grid.\n\n    Builds various useful structures that provide information about the\n    grid, including Fourier-transformed positions and real position arrays.\n\n    Parameters:\n        new_l (tuple of float): Tuple of floats representing the new box lengths.\n\n    Raises:\n\n        ValueError: \n            Raises error if the box length is not a tuple\n    \"\"\"\n\n    self.l = cp.array(new_l)\n\n    # Total volume\n    self.V = cp.prod(cp.array(self.l))\n\n    # Grid of real positions\n    self.grid = cp.asarray(\n        cp.meshgrid(\n            *[\n                cp.linspace(0, l, n)\n                for n, l in zip(\n                    self.grid_spec,\n                    self.l * (1 - 1 / cp.array(self.grid_spec)),\n                )\n            ]\n        )\n    )\n\n    # Grid of k positions\n    self.kgrid = cp.asarray(\n        cp.meshgrid(\n            *[\n                2\n                * cp.pi\n                / l\n                * cp.concatenate(\n                    (cp.arange(0, n / 2 + 1), cp.arange(-n / 2 + 1, 0)),\n                    axis=None,\n                )\n                for n, l in zip(self.grid_spec, self.l)\n            ]\n        )\n    )\n\n    self.k1 = cp.sum(self.kgrid, axis=0)\n    self.k2 = cp.sum(self.kgrid**2, axis=0)\n    self.dV = self.V / self.k2.size\n    self.dl = self.l / cp.array(self.grid_spec)\n\n    return\n</code></pre>"},{"location":"integrator/","title":"Exponential Time Integrator","text":"<p>Currently we only use exponential time integration (first order) which is the preferred method with other implementations. The details are described below. </p>"},{"location":"integrator/#polycomp.complex_langevin_ETD.CL_RK2","title":"<code>CL_RK2</code>","text":"<p>             Bases: <code>object</code></p> <p>Class for storing all of the necessary functions to run the Complex Langevin integration using Exponential Time Differencing.</p> <p>Attributes:</p> Name Type Description <code>ps</code> <code>PolymerSystem Object</code> <p>The polymer system integration is supposed to occur on.</p> <code>relax_rates</code> <code>cparray</code> <p>cparray of floats for the relaxation rate of each species.</p> <code>relax_temps</code> <code>cparray</code> <p>cparray of floats for the relaxation temps of each diagonalized w.</p> <code>psi_relax_rate</code> <code>float</code> <p>Float for the relaxation rate of psi.</p> <code>psi_temp</code> <code>float</code> <p>Float for the relaxation temp of psi.</p> <code>E</code> <code>float</code> <p>Float for the E (rescaled Bjerrum length) of the system.</p> <code>c_k_w</code> <code>cparray</code> <p>cparray of complex128 for the linear approximation of the response of force from fields derived using the weak inhomogeneity expansion.</p> <code>c_k_w</code> <code>cparray</code> <p>cparray of complex128 for the linear approximation of the response of force from charge field derived using the weak inhomogeneity expansion.</p> Source code in <code>polycomp/complex_langevin_ETD.py</code> <pre><code>class CL_RK2(object):\n    \"\"\"\n    Class for storing all of the necessary functions to run the Complex\n    Langevin integration using Exponential Time Differencing.\n\n    Attributes:\n        ps (PolymerSystem Object):\n            The polymer system integration is supposed to occur on.\n        relax_rates (cparray):\n            cparray of floats for the relaxation rate of each species.\n        relax_temps (cparray):\n            cparray of floats for the relaxation temps of each diagonalized w.\n        psi_relax_rate (float):\n            Float for the relaxation rate of psi.\n        psi_temp (float):\n            Float for the relaxation temp of psi.\n        E (float):\n            Float for the E (rescaled Bjerrum length) of the system.\n        c_k_w (cparray):\n            cparray of complex128 for the linear approximation of the response of force from\n            fields derived using the weak inhomogeneity expansion.\n        c_k_w (cparray):\n            cparray of complex128 for the linear approximation of the response of force from\n            charge field derived using the weak inhomogeneity expansion.\n    \"\"\"\n\n    def __init__(self, poly_sys, relax_rates, relax_temps, psi_relax_rate, psi_temp, E):\n        \"\"\"\n        Initialize integrator.\n\n        Parameters:\n            poly_sys (PolymerSystem object):\n                Polymer system that integration is supposed to occur on.\n            relax_rates (cparray):\n                cparray of floats for the relaxation rates of each diagonalized w.\n            relax_temps (cparray):\n                cparray of floats for the relaxation temps of each diagonalized w.\n            psi_relax_rate (float):\n                Float for the relaxation rate of psi.\n            psi_temp (float):\n                Float for the relaxation temp of psi.\n            E (float):\n                Float for the E (rescaled Bjerrum length) of the system.\n\n        Raises:\n            ValueError:\n                Raised if the shape of the relax rates doesn't match the shape\n                of poly_sys.\n        \"\"\"\n\n        super(CL_RK2, self).__init__()\n\n        self.ps = poly_sys\n        if len({self.ps.w_all.shape[0], len(relax_rates)}) != 1:\n            raise ValueError(\"Wrong sized relax rate or temperature\")\n        self.relax_rates = relax_rates\n        self.relax_temps = relax_temps\n        self.psi_relax_rate = psi_relax_rate\n        self.psi_temp = psi_temp\n        self.E = E\n        self.c_k_w = None\n\n    def ETD(self, for_pressure=False):\n        \"\"\"\n        Integrate one step of time with ETD algorithm.\n\n        Parameters:\n            for_pressure (bool, optional):\n                Boolean for whether or not the integration will be followed by pressure\n                calculations. This adds about 25% to the runtime, so it should be set as rarely\n                as possible. Default is False.\n        \"\"\"\n\n        # Get the densities\n        self.ps.get_densities(for_pressure=for_pressure)\n\n        # generate the random noise array that is going to be used with\n        # appropriate variance\n        w_dens_noise = cp.zeros_like(self.ps.w_all, dtype=complex)\n        psi_dens_noise = cp.zeros_like(self.ps.psi, dtype=complex)\n        for i in range(w_dens_noise.shape[0]):\n            w_dens_noise[i] = (\n                self.draw_gauss(\n                    cp.full(\n                        w_dens_noise[i].shape,\n                        cp.sqrt(\n                            2\n                            * self.relax_rates[i]\n                            * self.relax_temps[i]\n                            / self.ps.grid.dV\n                        ),\n                    )\n                )\n                * self.ps.gamma[i]\n            )\n\n        psi_noise = (\n            self.draw_gauss(\n                cp.full(\n                    w_dens_noise[i].shape,\n                    cp.sqrt(2 * self.psi_relax_rate * self.psi_temp / self.ps.grid.dV),\n                )\n            )\n            * 1j\n        )\n\n        w_trans_noise = self.ps.map_norm_from_dens(w_dens_noise)\n\n        d_w = self.relax_rates\n        d_psi = self.psi_relax_rate\n\n        R_k_w = self.fourier_along_axes(w_trans_noise, 0)\n        R_k_psi = cufft.fftn(psi_noise)\n\n        w_k = self.fourier_along_axes(self.ps.normal_w, 0)\n        psi_k = cufft.fftn(self.ps.psi)\n\n        # Start preparing the linear approximation term used in ETD1\n        u0_eig = self.ps.normal_evalues\n\n        # Debye function is the linear approximation using weak inhomogeneity\n        # expansion\n        debye_k = self.debye(self.ps.grid.k2) * cp.exp(\n            -self.ps.smear_const * self.ps.grid.k2\n        )\n\n        if self.c_k_w is None:\n            self.build_c_k(u0_eig, debye_k)\n\n        for i in range(w_k.shape[0]):\n            self.c_k_w[i].flat[0] = u0_eig[i]\n\n        # Need to sum over degenerate modes and fourier transform density to\n        # prepare for dynamics\n        red_dens = self.ps.remove_degeneracy(self.ps.phi_all)\n        red_dens = self.ps.gaussian_smear(red_dens, self.ps.smear_const)\n\n        real_dens_k = self.fourier_along_axes(red_dens, 0)\n\n        tot_charge = self.ps.get_total_charge()\n        tot_charge = self.ps.gaussian_smear(tot_charge, self.ps.smear_const)\n        tot_charge_k = cufft.fftn(tot_charge)\n\n        # Generate the force trajectories\n        F_k_w = (\n            -self.ps.gamma**2\n            * ((w_k.T / u0_eig) - self.ps.map_norm_from_dens(real_dens_k).T)\n        ).T\n\n        F_k_psi = psi_k * self.ps.grid.k2 / self.E - tot_charge_k\n\n        # Run ETD step\n        new_w_k = cp.zeros_like(w_k, dtype=complex)\n        for i in range(w_k.shape[0]):\n            new_w_k[i] = (\n                w_k[i]\n                - ((1 - cp.exp(-d_w[i] * self.c_k_w[i])) / self.c_k_w[i]) * F_k_w[i]\n                + (\n                    (1 - cp.exp(-2 * d_w[i] * self.c_k_w[i]))\n                    / (2 * d_w[i] * self.c_k_w[i])\n                )\n                ** (1 / 2)\n                * R_k_w[i]\n            )\n\n        # First element will be undefined, just set it to be unchanged\n        for i in range(new_w_k.shape[0]):\n            new_w_k[i].flat[0] = w_k[i].flat[0]\n\n        new_psi_k = (\n            psi_k\n            - ((1 - cp.exp(-d_psi * self.c_k_psi)) / self.c_k_psi) * F_k_psi\n            + ((1 - cp.exp(-2 * d_psi * self.c_k_psi)) / (2 * d_psi * self.c_k_psi))\n            ** (1 / 2)\n            * R_k_psi\n        )\n\n        # First element will be undefined, just set it to be unchanged\n        new_psi_k.flat[0] = 0\n\n        # Map back to real space\n        new_w = self.inverse_fourier_along_axes(new_w_k, 0)\n        new_psi = cufft.ifftn(new_psi_k, new_psi_k.shape)\n\n        self.ps.normal_w = new_w\n        self.ps.update_density_from_normal()\n\n        # Set psi to zero if E is zero\n        if self.E == 0:\n            self.ps.psi = cp.zeros_like(self.ps.psi, dtype=complex)\n            return\n\n        self.ps.psi = new_psi\n\n    def fourier_along_axes(self, array, axis):\n        \"\"\"\n        Fourier transform each grid separately along the first axis.\n\n        Needed when each grid is stored as a stacked array. Uses cufft for\n        Fourier transforms.\n\n        Parameters:\n            array (cparray):\n                Array to be Fourier transformed over.\n            axis (int):\n                Axis to be treated separately.\n        \"\"\"\n\n        f_array = cp.zeros_like(array, dtype=complex)\n\n        # code to slice out everything correctly\n        for i in range(array.shape[axis]):\n            sl = [slice(None)] * array.ndim\n            sl[axis] = i\n            f_array[tuple(sl)] = cufft.fftn(array[tuple(sl)])\n        return f_array\n\n    def inverse_fourier_along_axes(self, array, axis):\n        \"\"\"\n        Inverse Fourier transform each grid separately along the first axis.\n\n        Needed when each grid is stored as a stacked array. Uses cufft for\n        Inverse Fourier transforms.\n\n        Parameters:\n            array (cparray):\n                Array to be inverse Fourier transformed over.\n            axis (int):\n                Axis to be treated separately.\n        \"\"\"\n\n        inf_array = cp.zeros_like(array, dtype=complex)\n\n        # code to slice out everything correctly\n        for i in range(array.shape[axis]):\n            sl = [slice(None)] * array.ndim\n            sl[axis] = i\n            inf_array[tuple(sl)] = cufft.ifftn(\n                array[tuple(sl)], s=array[tuple(sl)].shape\n            )\n        return inf_array\n\n    def debye(self, k2):\n        \"\"\"\n        Debye function on a discrete grid.\n\n        Parameters:\n            k2 (cparray):\n                cparray representing k^2 at each grid point in k-space.\n        \"\"\"\n\n        debye = 2 / (k2**2) * (cp.exp(-k2) - 1 + k2)\n        return debye\n\n    def draw_gauss(self, variance):\n        \"\"\"\n        Draw Gaussian distribution independently at each point in space.\n\n        Parameters:\n            variance (float):\n                Variance of the Gaussian to be drawn.\n        \"\"\"\n\n        return cp.random.normal(0, variance.real)\n\n    def build_c_k(self, u0_eig, debye_k):\n        \"\"\"\n        Build the c_k coefficients for the ETD integrator.\n\n        Parameters:\n            u0_eig (cparray):\n                Eigenvalues of the u0 matrix.\n            debye_k (cparray):\n                Fourier-transformed Debye function.\n        \"\"\"\n\n        self.c_k_w = cp.zeros_like(self.ps.normal_w)\n        self.c_k_psi = self.ps.grid.k2 / self.E\n\n        # For every polymer we need to build a corresponding c_k, the procedure\n        # is fully desrcibed in the extended derivation\n        for polymer in self.ps.polymers:\n            segs = cp.array([x[1] for x in polymer.block_structure], dtype=float)\n            segs *= polymer.total_length / cp.sum(segs) / self.ps.N\n            ids = cp.array(\n                [self.ps.monomers.index(x[0]) for x in polymer.block_structure]\n            )\n            fract = self.ps.poly_dict[polymer]\n            alphk = self.ps.grid.k2\n            for i in range(len(polymer.block_structure)):\n                # TODO: Honestly, this stuff is to complicated for me to follow and\n                # should be done in greater detail with someone to check exactly\n                # DANGER: Factor of 2 is from Villet 2014, but I didn't have it\n                # in the derivation. Check this, all four instances of 2 *\n\n                # This is the leading g_jj term\n                self.c_k_w[ids[i]] += (\n                    2\n                    * fract\n                    / (alphk**2)\n                    * (alphk * segs[i] + cp.exp(-alphk * segs[i]) - 1)\n                    * cp.exp(-alphk * self.ps.smear_const**2)\n                )\n                self.c_k_psi += (\n                    2\n                    * fract\n                    / (alphk**2)\n                    * (alphk * segs[i] + cp.exp(-alphk * segs[i]) - 1)\n                    * polymer.block_structure[i][0].charge ** 2\n                    * cp.exp(-alphk * self.ps.smear_const**2)\n                )\n\n                for j in range(len(segs)):\n                    if j == i:\n                        continue\n                    if abs(i - j) == 1:\n                        gap = 0\n                    elif i &lt; j:\n                        gap = cp.sum(segs[i + 1 : j])\n                    else:\n                        gap = cp.sum(segs[i + 1 : j])\n                    # This is the g_ij term\n                    self.c_k_w[ids[i]] += (\n                        2\n                        * fract\n                        * cp.exp(-alphk * gap)\n                        / (alphk**2)\n                        * (1 - cp.exp(-alphk * segs[i]))\n                        * (1 - cp.exp(-alphk * segs[j]))\n                        * cp.exp(-alphk * self.ps.smear_const**2)\n                    )\n                    self.c_k_psi += (\n                        2\n                        * fract\n                        * cp.exp(-alphk * gap)\n                        / (alphk**2)\n                        * (1 - cp.exp(-alphk * segs[i]))\n                        * (1 - cp.exp(-alphk * segs[j]))\n                        * polymer.block_structure[i][0].charge\n                        * polymer.block_structure[j][0].charge\n                        * cp.exp(-alphk * self.ps.smear_const**2)\n                    )\n\n        # c_k_w is the linear term used to set the scale of the dynamics\n        self.c_k_w = self.ps.map_norm_from_dens(self.c_k_w)\n        self.c_k_w = (self.c_k_w.T + 1 / u0_eig).T\n\n        # Overwrite the zero mode term of each array\n        sl = [slice(1)] * self.c_k_w.ndim\n        sl[0] = slice(None)\n        insert_u0 = cp.expand_dims(1 / u0_eig, axis=tuple(range(1, self.c_k_w.ndim)))\n        self.c_k_w[tuple(sl)] = insert_u0\n\n        # In this case psi is going to get wiped anyways but we don't want division by\n        # zero\n        if self.E == 0:\n            return\n        self.c_k_psi.flat[0] = 1 / self.E\n\n        return\n</code></pre>"},{"location":"integrator/#polycomp.complex_langevin_ETD.CL_RK2.ETD","title":"<code>ETD(for_pressure=False)</code>","text":"<p>Integrate one step of time with ETD algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>for_pressure</code> <code>bool</code> <p>Boolean for whether or not the integration will be followed by pressure calculations. This adds about 25% to the runtime, so it should be set as rarely as possible. Default is False.</p> <code>False</code> Source code in <code>polycomp/complex_langevin_ETD.py</code> <pre><code>def ETD(self, for_pressure=False):\n    \"\"\"\n    Integrate one step of time with ETD algorithm.\n\n    Parameters:\n        for_pressure (bool, optional):\n            Boolean for whether or not the integration will be followed by pressure\n            calculations. This adds about 25% to the runtime, so it should be set as rarely\n            as possible. Default is False.\n    \"\"\"\n\n    # Get the densities\n    self.ps.get_densities(for_pressure=for_pressure)\n\n    # generate the random noise array that is going to be used with\n    # appropriate variance\n    w_dens_noise = cp.zeros_like(self.ps.w_all, dtype=complex)\n    psi_dens_noise = cp.zeros_like(self.ps.psi, dtype=complex)\n    for i in range(w_dens_noise.shape[0]):\n        w_dens_noise[i] = (\n            self.draw_gauss(\n                cp.full(\n                    w_dens_noise[i].shape,\n                    cp.sqrt(\n                        2\n                        * self.relax_rates[i]\n                        * self.relax_temps[i]\n                        / self.ps.grid.dV\n                    ),\n                )\n            )\n            * self.ps.gamma[i]\n        )\n\n    psi_noise = (\n        self.draw_gauss(\n            cp.full(\n                w_dens_noise[i].shape,\n                cp.sqrt(2 * self.psi_relax_rate * self.psi_temp / self.ps.grid.dV),\n            )\n        )\n        * 1j\n    )\n\n    w_trans_noise = self.ps.map_norm_from_dens(w_dens_noise)\n\n    d_w = self.relax_rates\n    d_psi = self.psi_relax_rate\n\n    R_k_w = self.fourier_along_axes(w_trans_noise, 0)\n    R_k_psi = cufft.fftn(psi_noise)\n\n    w_k = self.fourier_along_axes(self.ps.normal_w, 0)\n    psi_k = cufft.fftn(self.ps.psi)\n\n    # Start preparing the linear approximation term used in ETD1\n    u0_eig = self.ps.normal_evalues\n\n    # Debye function is the linear approximation using weak inhomogeneity\n    # expansion\n    debye_k = self.debye(self.ps.grid.k2) * cp.exp(\n        -self.ps.smear_const * self.ps.grid.k2\n    )\n\n    if self.c_k_w is None:\n        self.build_c_k(u0_eig, debye_k)\n\n    for i in range(w_k.shape[0]):\n        self.c_k_w[i].flat[0] = u0_eig[i]\n\n    # Need to sum over degenerate modes and fourier transform density to\n    # prepare for dynamics\n    red_dens = self.ps.remove_degeneracy(self.ps.phi_all)\n    red_dens = self.ps.gaussian_smear(red_dens, self.ps.smear_const)\n\n    real_dens_k = self.fourier_along_axes(red_dens, 0)\n\n    tot_charge = self.ps.get_total_charge()\n    tot_charge = self.ps.gaussian_smear(tot_charge, self.ps.smear_const)\n    tot_charge_k = cufft.fftn(tot_charge)\n\n    # Generate the force trajectories\n    F_k_w = (\n        -self.ps.gamma**2\n        * ((w_k.T / u0_eig) - self.ps.map_norm_from_dens(real_dens_k).T)\n    ).T\n\n    F_k_psi = psi_k * self.ps.grid.k2 / self.E - tot_charge_k\n\n    # Run ETD step\n    new_w_k = cp.zeros_like(w_k, dtype=complex)\n    for i in range(w_k.shape[0]):\n        new_w_k[i] = (\n            w_k[i]\n            - ((1 - cp.exp(-d_w[i] * self.c_k_w[i])) / self.c_k_w[i]) * F_k_w[i]\n            + (\n                (1 - cp.exp(-2 * d_w[i] * self.c_k_w[i]))\n                / (2 * d_w[i] * self.c_k_w[i])\n            )\n            ** (1 / 2)\n            * R_k_w[i]\n        )\n\n    # First element will be undefined, just set it to be unchanged\n    for i in range(new_w_k.shape[0]):\n        new_w_k[i].flat[0] = w_k[i].flat[0]\n\n    new_psi_k = (\n        psi_k\n        - ((1 - cp.exp(-d_psi * self.c_k_psi)) / self.c_k_psi) * F_k_psi\n        + ((1 - cp.exp(-2 * d_psi * self.c_k_psi)) / (2 * d_psi * self.c_k_psi))\n        ** (1 / 2)\n        * R_k_psi\n    )\n\n    # First element will be undefined, just set it to be unchanged\n    new_psi_k.flat[0] = 0\n\n    # Map back to real space\n    new_w = self.inverse_fourier_along_axes(new_w_k, 0)\n    new_psi = cufft.ifftn(new_psi_k, new_psi_k.shape)\n\n    self.ps.normal_w = new_w\n    self.ps.update_density_from_normal()\n\n    # Set psi to zero if E is zero\n    if self.E == 0:\n        self.ps.psi = cp.zeros_like(self.ps.psi, dtype=complex)\n        return\n\n    self.ps.psi = new_psi\n</code></pre>"},{"location":"integrator/#polycomp.complex_langevin_ETD.CL_RK2.__init__","title":"<code>__init__(poly_sys, relax_rates, relax_temps, psi_relax_rate, psi_temp, E)</code>","text":"<p>Initialize integrator.</p> <p>Parameters:</p> Name Type Description Default <code>poly_sys</code> <code>PolymerSystem object</code> <p>Polymer system that integration is supposed to occur on.</p> required <code>relax_rates</code> <code>cparray</code> <p>cparray of floats for the relaxation rates of each diagonalized w.</p> required <code>relax_temps</code> <code>cparray</code> <p>cparray of floats for the relaxation temps of each diagonalized w.</p> required <code>psi_relax_rate</code> <code>float</code> <p>Float for the relaxation rate of psi.</p> required <code>psi_temp</code> <code>float</code> <p>Float for the relaxation temp of psi.</p> required <code>E</code> <code>float</code> <p>Float for the E (rescaled Bjerrum length) of the system.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised if the shape of the relax rates doesn't match the shape of poly_sys.</p> Source code in <code>polycomp/complex_langevin_ETD.py</code> <pre><code>def __init__(self, poly_sys, relax_rates, relax_temps, psi_relax_rate, psi_temp, E):\n    \"\"\"\n    Initialize integrator.\n\n    Parameters:\n        poly_sys (PolymerSystem object):\n            Polymer system that integration is supposed to occur on.\n        relax_rates (cparray):\n            cparray of floats for the relaxation rates of each diagonalized w.\n        relax_temps (cparray):\n            cparray of floats for the relaxation temps of each diagonalized w.\n        psi_relax_rate (float):\n            Float for the relaxation rate of psi.\n        psi_temp (float):\n            Float for the relaxation temp of psi.\n        E (float):\n            Float for the E (rescaled Bjerrum length) of the system.\n\n    Raises:\n        ValueError:\n            Raised if the shape of the relax rates doesn't match the shape\n            of poly_sys.\n    \"\"\"\n\n    super(CL_RK2, self).__init__()\n\n    self.ps = poly_sys\n    if len({self.ps.w_all.shape[0], len(relax_rates)}) != 1:\n        raise ValueError(\"Wrong sized relax rate or temperature\")\n    self.relax_rates = relax_rates\n    self.relax_temps = relax_temps\n    self.psi_relax_rate = psi_relax_rate\n    self.psi_temp = psi_temp\n    self.E = E\n    self.c_k_w = None\n</code></pre>"},{"location":"integrator/#polycomp.complex_langevin_ETD.CL_RK2.build_c_k","title":"<code>build_c_k(u0_eig, debye_k)</code>","text":"<p>Build the c_k coefficients for the ETD integrator.</p> <p>Parameters:</p> Name Type Description Default <code>u0_eig</code> <code>cparray</code> <p>Eigenvalues of the u0 matrix.</p> required <code>debye_k</code> <code>cparray</code> <p>Fourier-transformed Debye function.</p> required Source code in <code>polycomp/complex_langevin_ETD.py</code> <pre><code>def build_c_k(self, u0_eig, debye_k):\n    \"\"\"\n    Build the c_k coefficients for the ETD integrator.\n\n    Parameters:\n        u0_eig (cparray):\n            Eigenvalues of the u0 matrix.\n        debye_k (cparray):\n            Fourier-transformed Debye function.\n    \"\"\"\n\n    self.c_k_w = cp.zeros_like(self.ps.normal_w)\n    self.c_k_psi = self.ps.grid.k2 / self.E\n\n    # For every polymer we need to build a corresponding c_k, the procedure\n    # is fully desrcibed in the extended derivation\n    for polymer in self.ps.polymers:\n        segs = cp.array([x[1] for x in polymer.block_structure], dtype=float)\n        segs *= polymer.total_length / cp.sum(segs) / self.ps.N\n        ids = cp.array(\n            [self.ps.monomers.index(x[0]) for x in polymer.block_structure]\n        )\n        fract = self.ps.poly_dict[polymer]\n        alphk = self.ps.grid.k2\n        for i in range(len(polymer.block_structure)):\n            # TODO: Honestly, this stuff is to complicated for me to follow and\n            # should be done in greater detail with someone to check exactly\n            # DANGER: Factor of 2 is from Villet 2014, but I didn't have it\n            # in the derivation. Check this, all four instances of 2 *\n\n            # This is the leading g_jj term\n            self.c_k_w[ids[i]] += (\n                2\n                * fract\n                / (alphk**2)\n                * (alphk * segs[i] + cp.exp(-alphk * segs[i]) - 1)\n                * cp.exp(-alphk * self.ps.smear_const**2)\n            )\n            self.c_k_psi += (\n                2\n                * fract\n                / (alphk**2)\n                * (alphk * segs[i] + cp.exp(-alphk * segs[i]) - 1)\n                * polymer.block_structure[i][0].charge ** 2\n                * cp.exp(-alphk * self.ps.smear_const**2)\n            )\n\n            for j in range(len(segs)):\n                if j == i:\n                    continue\n                if abs(i - j) == 1:\n                    gap = 0\n                elif i &lt; j:\n                    gap = cp.sum(segs[i + 1 : j])\n                else:\n                    gap = cp.sum(segs[i + 1 : j])\n                # This is the g_ij term\n                self.c_k_w[ids[i]] += (\n                    2\n                    * fract\n                    * cp.exp(-alphk * gap)\n                    / (alphk**2)\n                    * (1 - cp.exp(-alphk * segs[i]))\n                    * (1 - cp.exp(-alphk * segs[j]))\n                    * cp.exp(-alphk * self.ps.smear_const**2)\n                )\n                self.c_k_psi += (\n                    2\n                    * fract\n                    * cp.exp(-alphk * gap)\n                    / (alphk**2)\n                    * (1 - cp.exp(-alphk * segs[i]))\n                    * (1 - cp.exp(-alphk * segs[j]))\n                    * polymer.block_structure[i][0].charge\n                    * polymer.block_structure[j][0].charge\n                    * cp.exp(-alphk * self.ps.smear_const**2)\n                )\n\n    # c_k_w is the linear term used to set the scale of the dynamics\n    self.c_k_w = self.ps.map_norm_from_dens(self.c_k_w)\n    self.c_k_w = (self.c_k_w.T + 1 / u0_eig).T\n\n    # Overwrite the zero mode term of each array\n    sl = [slice(1)] * self.c_k_w.ndim\n    sl[0] = slice(None)\n    insert_u0 = cp.expand_dims(1 / u0_eig, axis=tuple(range(1, self.c_k_w.ndim)))\n    self.c_k_w[tuple(sl)] = insert_u0\n\n    # In this case psi is going to get wiped anyways but we don't want division by\n    # zero\n    if self.E == 0:\n        return\n    self.c_k_psi.flat[0] = 1 / self.E\n\n    return\n</code></pre>"},{"location":"integrator/#polycomp.complex_langevin_ETD.CL_RK2.debye","title":"<code>debye(k2)</code>","text":"<p>Debye function on a discrete grid.</p> <p>Parameters:</p> Name Type Description Default <code>k2</code> <code>cparray</code> <p>cparray representing k^2 at each grid point in k-space.</p> required Source code in <code>polycomp/complex_langevin_ETD.py</code> <pre><code>def debye(self, k2):\n    \"\"\"\n    Debye function on a discrete grid.\n\n    Parameters:\n        k2 (cparray):\n            cparray representing k^2 at each grid point in k-space.\n    \"\"\"\n\n    debye = 2 / (k2**2) * (cp.exp(-k2) - 1 + k2)\n    return debye\n</code></pre>"},{"location":"integrator/#polycomp.complex_langevin_ETD.CL_RK2.draw_gauss","title":"<code>draw_gauss(variance)</code>","text":"<p>Draw Gaussian distribution independently at each point in space.</p> <p>Parameters:</p> Name Type Description Default <code>variance</code> <code>float</code> <p>Variance of the Gaussian to be drawn.</p> required Source code in <code>polycomp/complex_langevin_ETD.py</code> <pre><code>def draw_gauss(self, variance):\n    \"\"\"\n    Draw Gaussian distribution independently at each point in space.\n\n    Parameters:\n        variance (float):\n            Variance of the Gaussian to be drawn.\n    \"\"\"\n\n    return cp.random.normal(0, variance.real)\n</code></pre>"},{"location":"integrator/#polycomp.complex_langevin_ETD.CL_RK2.fourier_along_axes","title":"<code>fourier_along_axes(array, axis)</code>","text":"<p>Fourier transform each grid separately along the first axis.</p> <p>Needed when each grid is stored as a stacked array. Uses cufft for Fourier transforms.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>cparray</code> <p>Array to be Fourier transformed over.</p> required <code>axis</code> <code>int</code> <p>Axis to be treated separately.</p> required Source code in <code>polycomp/complex_langevin_ETD.py</code> <pre><code>def fourier_along_axes(self, array, axis):\n    \"\"\"\n    Fourier transform each grid separately along the first axis.\n\n    Needed when each grid is stored as a stacked array. Uses cufft for\n    Fourier transforms.\n\n    Parameters:\n        array (cparray):\n            Array to be Fourier transformed over.\n        axis (int):\n            Axis to be treated separately.\n    \"\"\"\n\n    f_array = cp.zeros_like(array, dtype=complex)\n\n    # code to slice out everything correctly\n    for i in range(array.shape[axis]):\n        sl = [slice(None)] * array.ndim\n        sl[axis] = i\n        f_array[tuple(sl)] = cufft.fftn(array[tuple(sl)])\n    return f_array\n</code></pre>"},{"location":"integrator/#polycomp.complex_langevin_ETD.CL_RK2.inverse_fourier_along_axes","title":"<code>inverse_fourier_along_axes(array, axis)</code>","text":"<p>Inverse Fourier transform each grid separately along the first axis.</p> <p>Needed when each grid is stored as a stacked array. Uses cufft for Inverse Fourier transforms.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>cparray</code> <p>Array to be inverse Fourier transformed over.</p> required <code>axis</code> <code>int</code> <p>Axis to be treated separately.</p> required Source code in <code>polycomp/complex_langevin_ETD.py</code> <pre><code>def inverse_fourier_along_axes(self, array, axis):\n    \"\"\"\n    Inverse Fourier transform each grid separately along the first axis.\n\n    Needed when each grid is stored as a stacked array. Uses cufft for\n    Inverse Fourier transforms.\n\n    Parameters:\n        array (cparray):\n            Array to be inverse Fourier transformed over.\n        axis (int):\n            Axis to be treated separately.\n    \"\"\"\n\n    inf_array = cp.zeros_like(array, dtype=complex)\n\n    # code to slice out everything correctly\n    for i in range(array.shape[axis]):\n        sl = [slice(None)] * array.ndim\n        sl[axis] = i\n        inf_array[tuple(sl)] = cufft.ifftn(\n            array[tuple(sl)], s=array[tuple(sl)].shape\n        )\n    return inf_array\n</code></pre>"},{"location":"inventory/","title":"Species Inventory","text":""},{"location":"inventory/#polycomp.base.Monomer","title":"<code>Monomer</code>","text":"<p>             Bases: <code>object</code></p> <p>Class for the monomer of one species in the simulation.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>string</code> <p>Unique monomer name.</p> <code>has_volume</code> <code>bool</code> <p>Whether the monomer occupies volume.</p> <code>identity</code> <code>string</code> <p>Identity of the monomer, probably {polymer, solvent, salt}.</p> <code>charge</code> <code>float</code> <p>Charge of the monomer.</p> Source code in <code>polycomp/base.py</code> <pre><code>class Monomer(object):\n    \"\"\"\n    Class for the monomer of one species in the simulation.\n\n    Attributes:\n        name (string):\n            Unique monomer name.\n        has_volume (bool):\n            Whether the monomer occupies volume.\n        identity (string):\n            Identity of the monomer, probably {polymer, solvent, salt}.\n        charge (float):\n            Charge of the monomer.\n    \"\"\"\n\n    def __init__(self, name, charge, identity=\"solvent\", has_volume=True):\n        \"\"\"\n        Initialize Monomer object.\n\n        Parameters:\n            name (string):\n                Unique monomer name.\n            identity (string):\n                What type of species the monomer is.\n            has_volume (bool):\n                Whether the monomer occupies volume.\n        \"\"\"\n\n        self.name = name\n        self.has_volume = has_volume\n        self.identity = identity\n        self.charge = charge\n\n    def __repr__(self):\n        return self.name\n</code></pre>"},{"location":"inventory/#polycomp.base.Monomer.__init__","title":"<code>__init__(name, charge, identity='solvent', has_volume=True)</code>","text":"<p>Initialize Monomer object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>string</code> <p>Unique monomer name.</p> required <code>identity</code> <code>string</code> <p>What type of species the monomer is.</p> <code>'solvent'</code> <code>has_volume</code> <code>bool</code> <p>Whether the monomer occupies volume.</p> <code>True</code> Source code in <code>polycomp/base.py</code> <pre><code>def __init__(self, name, charge, identity=\"solvent\", has_volume=True):\n    \"\"\"\n    Initialize Monomer object.\n\n    Parameters:\n        name (string):\n            Unique monomer name.\n        identity (string):\n            What type of species the monomer is.\n        has_volume (bool):\n            Whether the monomer occupies volume.\n    \"\"\"\n\n    self.name = name\n    self.has_volume = has_volume\n    self.identity = identity\n    self.charge = charge\n</code></pre>"},{"location":"inventory/#polycomp.base.Polymer","title":"<code>Polymer</code>","text":"<p>             Bases: <code>object</code></p> <p>Class to store all the information for one type of polymer.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>string</code> <p>Unique name of a polymer.</p> <code>total_length</code> <code>float</code> <p>Total length of the polymer for integration.</p> <code>block_structure</code> <code>tuple</code> <p>Tuple of dicts containing the length of component blocks within the polymer.</p> <code>struct</code> <code>ndarray</code> <p>Array of Monomer objects representing linear polymer structure.</p> <code>h_struct</code> <code>cparray</code> <p>Array of floats for the length of each section of the structure.</p> <code>fastener</code> <code>cparray</code> <p>cparray indicating where the polymer is fastened.</p> Source code in <code>polycomp/base.py</code> <pre><code>class Polymer(object):\n    \"\"\"\n    Class to store all the information for one type of polymer.\n\n    Attributes:\n        name (string):\n            Unique name of a polymer.\n        total_length (float):\n            Total length of the polymer for integration.\n        block_structure (tuple):\n            Tuple of dicts containing the length of component blocks within the\n            polymer.\n        struct (ndarray):\n            Array of Monomer objects representing linear polymer structure.\n        h_struct (cparray):\n            Array of floats for the length of each section of the structure.\n        fastener (cparray):\n            cparray indicating where the polymer is fastened.\n    \"\"\"\n\n    def __init__(self, name, total_length, block_structure, fastener=None):\n        \"\"\"\n        Initialize Polymer object.\n\n        Parameters:\n            name (string):\n                Unique name.\n            total_length (float):\n                Total length along the polymer.\n            block_structure (tuple):\n                Tuple of dictionaries mapping monomer objects to lengths along the polymer.\n        \"\"\"\n\n        super(Polymer, self).__init__()\n        self.name = name\n        self.total_length = total_length\n        self.block_structure = block_structure\n\n        self.struct = None\n        # Identify which species are in any polymer\n        for monomer in set(p[0] for p in self.block_structure):\n            if monomer.identity != \"polymer\":\n                monomer.identity = \"polymer\"\n\n        self.identity = \"entire_polymer\"\n        self.fastener = fastener\n\n    def __repr__(self):\n        return str(self.block_structure)\n\n    def build_working_polymer(self, h, total_h):\n        \"\"\"\n        Build the polymer structure that will be used for integration.\n\n        Built-in method to construct a working polymer during integration\n        according to parameters specific to the simulation run.\n\n        Parameters:\n            h (float):\n                Maximum integration segment length.\n\n        Raises:\n            ValueError:\n                Raises an error if the polymer already has a built structure. At\n                present, there is no reason that a polymer structure should be built\n                more than once in a single simulation.\n        \"\"\"\n\n        # Used to generate a string of h lengths and polymer species identities\n        if self.struct is not None:\n            raise ValueError(\"polymer structure should only be built once\")\n        hold_struct = []\n        hold_h_struct = []\n        where = 0.0\n        end = 0.0\n\n        # Splits up each block evenly while keeping h below target\n        thresh = 1e-10\n        for name_tuple in self.block_structure:\n            end = name_tuple[1] * total_h\n            units = int(end // h)\n            if end % h &gt; thresh:\n                units += 1\n            hold_struct = hold_struct + ([name_tuple[0]] * units)\n            hold_h_struct = hold_h_struct + ([end / units] * units)\n\n        self.struct = np.asarray(hold_struct)\n        self.h_struct = cp.asarray(hold_h_struct, dtype=\"float64\")\n        return\n</code></pre>"},{"location":"inventory/#polycomp.base.Polymer.__init__","title":"<code>__init__(name, total_length, block_structure, fastener=None)</code>","text":"<p>Initialize Polymer object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>string</code> <p>Unique name.</p> required <code>total_length</code> <code>float</code> <p>Total length along the polymer.</p> required <code>block_structure</code> <code>tuple</code> <p>Tuple of dictionaries mapping monomer objects to lengths along the polymer.</p> required Source code in <code>polycomp/base.py</code> <pre><code>def __init__(self, name, total_length, block_structure, fastener=None):\n    \"\"\"\n    Initialize Polymer object.\n\n    Parameters:\n        name (string):\n            Unique name.\n        total_length (float):\n            Total length along the polymer.\n        block_structure (tuple):\n            Tuple of dictionaries mapping monomer objects to lengths along the polymer.\n    \"\"\"\n\n    super(Polymer, self).__init__()\n    self.name = name\n    self.total_length = total_length\n    self.block_structure = block_structure\n\n    self.struct = None\n    # Identify which species are in any polymer\n    for monomer in set(p[0] for p in self.block_structure):\n        if monomer.identity != \"polymer\":\n            monomer.identity = \"polymer\"\n\n    self.identity = \"entire_polymer\"\n    self.fastener = fastener\n</code></pre>"},{"location":"inventory/#polycomp.base.Polymer.build_working_polymer","title":"<code>build_working_polymer(h, total_h)</code>","text":"<p>Build the polymer structure that will be used for integration.</p> <p>Built-in method to construct a working polymer during integration according to parameters specific to the simulation run.</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Maximum integration segment length.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Raises an error if the polymer already has a built structure. At present, there is no reason that a polymer structure should be built more than once in a single simulation.</p> Source code in <code>polycomp/base.py</code> <pre><code>def build_working_polymer(self, h, total_h):\n    \"\"\"\n    Build the polymer structure that will be used for integration.\n\n    Built-in method to construct a working polymer during integration\n    according to parameters specific to the simulation run.\n\n    Parameters:\n        h (float):\n            Maximum integration segment length.\n\n    Raises:\n        ValueError:\n            Raises an error if the polymer already has a built structure. At\n            present, there is no reason that a polymer structure should be built\n            more than once in a single simulation.\n    \"\"\"\n\n    # Used to generate a string of h lengths and polymer species identities\n    if self.struct is not None:\n        raise ValueError(\"polymer structure should only be built once\")\n    hold_struct = []\n    hold_h_struct = []\n    where = 0.0\n    end = 0.0\n\n    # Splits up each block evenly while keeping h below target\n    thresh = 1e-10\n    for name_tuple in self.block_structure:\n        end = name_tuple[1] * total_h\n        units = int(end // h)\n        if end % h &gt; thresh:\n            units += 1\n        hold_struct = hold_struct + ([name_tuple[0]] * units)\n        hold_h_struct = hold_h_struct + ([end / units] * units)\n\n    self.struct = np.asarray(hold_struct)\n    self.h_struct = cp.asarray(hold_h_struct, dtype=\"float64\")\n    return\n</code></pre>"},{"location":"math_CL/","title":"math CL","text":"<p>The actual integration scheme used is complex Langevin, which promotes the fields to </p>"},{"location":"math_overview/","title":"Overview","text":"<p>This section is intended to serve as a broad look at the mathematical backing for the code and articulate some of the design decisions we have made. The best general  work on polymer field theories are Glenn Fredrickson's book \"The Equilibrium Theory  of Inhomogeneous Polymers.\" This will be a shorter description of the math behind the code, with a particular focus on choices we have made in this implementation of the code. Full mathematical descriptions can be found in our  corresponding paper Insert paper once we have it.</p> <p>At a high level, the overall polymer field theory method operates by sampling over  chemical potential fields and finding the corresponding real density and partition  functions associated with any polymer being simulated. By iterating on our chemical  potential fields, we can find free energy minima and sample around them. From there we  can directly compute other observables such as chemical potential, pressure, structure factor, etc. </p> <p>In general the code acts on fields \\(\\{\\mu_i\\}/\\{\\psi_i\\}/\\varphi\\) and densities  \\(\\{\\rho_i\\}\\). Actual sampling and fictitious dynamics modify the fields to try to sample an equilibrium distribution that can be used to evaluate observables. </p>"},{"location":"math_overview/#core-assumptions-and-limitations","title":"Core assumptions and limitations","text":"<ul> <li> <p>Guassian Chain Assumption</p> <p>We model all polymers as Gaussian chains. This means there is no stiffness to the  polymers. The model assumes that polymers can occupy any space curve. </p> </li> <li> <p>Flory-Huggin and Charged Interactions</p> <p>All interactions except for charged interactions are represented as pairwise  Flory-Huggins interactions. </p> </li> <li> <p>Soft Repulsions</p> <p>For regularization purposes, all interactions are smeared, which can be interpreted as either having a distributed mass density or a softer interaction than the FH  interaction would normally imply. </p> </li> <li> <p>No True Dynamics</p> <p>Dynamics in polymer field theories is a complicated issue, and while the code does  run fictitious dynamics to equilibrate the simulation, we currently only can evaluate  equilibrium configurations. </p> </li> </ul>"},{"location":"mde/","title":"Modified Diffusion Equation","text":"<p>Set of functions specialized in evaluating the modified diffusion equations. C kernels  are available separately. </p>"},{"location":"mde/#polycomp.mde.integrate_s","title":"<code>integrate_s(struct, h_struct, species_dict, q_r_start, q_r_dag_start, grid, fastener=None)</code>","text":"<p>Function to integrate one polymer.</p> <p>Takes the polymer structure and underlying chemical potential and generates values for the modified diffusion equation at every step along the polymer.</p> <p>Parameters:</p> Name Type Description Default <code>struct</code> <code>ndarray</code> <p>ndarray of Monomers containing the corresponding monomer type along the polymer.</p> required <code>h_struct</code> <code>cparray</code> <p>cparray of floats containing the length of each segment along the polymer.</p> required <code>species_dict</code> <code>dict</code> <p>Dictionary of species to ints representing the mapping between monomer types and the index for their corresponding density and potential.</p> required <code>q_r_start</code> <code>cparray</code> <p>cparray of complex128 representing the initial value of q.</p> required <code>q_r_dag_start</code> <code>cparray</code> <p>cparray of complex128 representing the initial value of q_dagger.</p> required <code>grid</code> <code>Grid object</code> <p>System grid.</p> required Source code in <code>polycomp/mde.py</code> <pre><code>def integrate_s(\n    struct,\n    h_struct,\n    species_dict,\n    q_r_start,\n    q_r_dag_start,\n    grid,\n    fastener=None,\n):\n    \"\"\"\n    Function to integrate one polymer.\n\n    Takes the polymer structure and underlying chemical potential and generates\n    values for the modified diffusion equation at every step along the polymer.\n\n    Parameters:\n        struct (ndarray):\n            ndarray of Monomers containing the corresponding monomer type along the\n            polymer.\n        h_struct (cparray):\n            cparray of floats containing the length of each segment along the polymer.\n        species_dict (dict):\n            Dictionary of species to ints representing the mapping between monomer types\n            and the index for their corresponding density and potential.\n        q_r_start (cparray):\n            cparray of complex128 representing the initial value of q.\n        q_r_dag_start (cparray):\n            cparray of complex128 representing the initial value of q_dagger.\n        grid (Grid object):\n            System grid.\n    \"\"\"\n\n    # integrates using each point in struct as an integration point\n    # returns the q_r, q_r_dagger, and the key designating point along struct\n    # they belong too\n\n    q_r = q_r_start\n    q_r_dag = q_r_dag_start\n\n    s_seg = len(struct)\n\n    # write the list of all q_r points along polymer structure\n    q_r_s = cp.zeros((s_seg + 1, *q_r.shape), dtype=complex)\n    q_r_dag_s = cp.zeros((s_seg + 1, *q_r.shape), dtype=complex)\n\n    # index to ensure sampling happened at the correct places\n    i = 0\n\n    # itialize q_r_s at q_r_start\n    q_r_s[0] = q_r\n    q_r_dag_s[-1] = q_r_dag\n\n    # advance, integrate and write key and q_r_s\n    for bead in struct:\n        # implements a 4th order integrator\n        q_r_1 = s_step(q_r, h_struct[i], species_dict[bead], grid)\n        q_r_2 = s_step(q_r, h_struct[i] / 2.0, species_dict[bead], grid)\n        q_r_2 = s_step(q_r_2, h_struct[i] / 2.0, species_dict[bead], grid)\n        q_r = (4 * q_r_2 - q_r_1) / 3\n        i += 1\n        q_r_s[i] = q_r\n\n    # If the polymer is symmetric, we can use the symmetry to save time\n    if (\n        cp.array_equal(struct, cp.flip(struct))\n        and cp.array_equal(h_struct, cp.flip(h_struct))\n        and fastener is None\n    ):\n        q_r_dag_s = cp.flip(q_r_s, axis=0)\n        return q_r_s, q_r_dag_s\n\n    if fastener is not None:\n        q_r_s[0] = q_r = cp.array(fastener.density, dtype=complex) / q_r_dag_s[-1]\n\n    # retreat, integrate, and write q_r_dag_s\n    for bead in reversed(struct):\n        i -= 1\n        q_r_dag_1 = s_step(q_r_dag, h_struct[i], species_dict[bead], grid)\n        q_r_dag_2 = s_step(q_r_dag, h_struct[i] / 2.0, species_dict[bead], grid)\n        q_r_dag_2 = s_step(q_r_dag_2, h_struct[i] / 2.0, species_dict[bead], grid)\n        q_r_dag = (4 * q_r_dag_2 - q_r_dag_1) / 3\n        q_r_dag_s[i] = q_r_dag\n\n    return q_r_s, q_r_dag_s\n</code></pre>"},{"location":"mde/#polycomp.mde.s_step","title":"<code>s_step(q_r, h, w_P, grid)</code>","text":"<p>Function to run one step of Modified diffusion integration.</p> <p>Uses cupy custom functions to more efficiently compute the products with C code, otherwise just products and Fourier transforms.</p> <p>Parameters:</p> Name Type Description Default <code>q_r</code> <code>cparray</code> <p>sys_dim array of complex128 representing a single q value.</p> required <code>h</code> <code>float</code> <p>Integration step size.</p> required <code>w_P</code> <code>cparray</code> <p>sys_dim array of complex128 representing effective chemical potential.</p> required <code>grid</code> <code>Grid object</code> <p>System grid.</p> required Source code in <code>polycomp/mde.py</code> <pre><code>def s_step(q_r, h, w_P, grid):\n    \"\"\"\n    Function to run one step of Modified diffusion integration.\n\n    Uses cupy custom functions to more efficiently compute the products with C\n    code, otherwise just products and Fourier transforms.\n\n    Parameters:\n        q_r (cparray):\n            sys_dim array of complex128 representing a single q value.\n        h (float):\n            Integration step size.\n        w_P (cparray):\n            sys_dim array of complex128 representing effective chemical potential.\n        grid (Grid object):\n            System grid.\n    \"\"\"\n\n    # Run a single step of Equation 13\n    q_k = cp.zeros(q_r.shape, dtype=complex)\n    q_r_t = exp_mult(q_r, w_P, h / 2.0)\n\n    q_k = cufft.fftn(q_r_t, s=q_r_t.shape)\n    q_k = exp_mult_comp(q_k, grid.k2, h)\n    q_r_t = cufft.ifftn(q_k, s=q_k.shape)\n\n    q_r_t = exp_mult(q_r_t, w_P, h / 2.0)\n    return q_r_t\n</code></pre>"},{"location":"observables/","title":"Structure Factor","text":""},{"location":"observables/#polycomp.observables.get_chemical_potential","title":"<code>get_chemical_potential(polymer_system)</code>","text":"<p>Function to compute the chemical potential of the system.</p> <p>Returns:</p> Name Type Description <code>chem_pot_dict</code> <code>dict</code> <p>Dictionary of chemical potentials for each species.</p> Source code in <code>polycomp/observables.py</code> <pre><code>def get_chemical_potential(polymer_system):\n    \"\"\"\n    Function to compute the chemical potential of the system.\n\n    Returns:\n        chem_pot_dict (dict):\n            Dictionary of chemical potentials for each species.\n    \"\"\"\n\n    polymer_system.chem_pot_dict = {}\n\n    avg_mass = cp.sum(polymer_system.phi_all) / polymer_system.grid.k2.size\n    avg_red_mass = polymer_system.remove_degeneracy(\n        cp.sum(polymer_system.phi_all, axis=(range(1, polymer_system.phi_all.ndim))) / polymer_system.grid.k2.size\n    )\n    if polymer_system.use_salts:\n        polymer_system.get_salt_concs()\n    for species in polymer_system.Q_dict:\n        polymer_system.chem_pot_dict[species] = 0j\n        if species in polymer_system.poly_dict:\n            # simulation contribution\n            polymer_system.chem_pot_dict[species] -= cp.log(polymer_system.Q_dict[species])\n            polymer_system.chem_pot_dict[species] += cp.log(polymer_system.poly_dict[species])\n            alpha = cp.zeros_like(avg_red_mass)\n\n            for h, spec in zip(species.h_struct, species.struct):\n                alpha[polymer_system.rev_degen_dict[spec]] += h\n            polymer_system.chem_pot_dict[species] += alpha @ polymer_system.red_FH_mat @ avg_red_mass.T\n\n        elif species in polymer_system.solvent_dict:\n            # simulation contribution\n            polymer_system.chem_pot_dict[species] += cp.log(polymer_system.Q_dict[species])\n            polymer_system.chem_pot_dict[species] += cp.log(polymer_system.solvent_dict[species])\n            # Enthalpic contribution\n            alpha = cp.zeros_like(avg_red_mass)\n            alpha[polymer_system.rev_degen_dict[species]] += 1\n            # TODO: maybe this should be phi rather than total mass, kind of unclear but I think this is right\n            # polymer_system.chem_pot_dict[species] += -(avg_red_mass@polymer_system.red_FH_mat@avg_red_mass.T/2) / polymer_system.N\n            polymer_system.chem_pot_dict[species] += (\n                2 / 2 * (alpha @ polymer_system.red_FH_mat @ avg_red_mass.T) / polymer_system.N\n            )\n\n        elif species in polymer_system.salts:\n            polymer_system.chem_pot_dict[species] -= cp.log(polymer_system.Q_dict[species])\n            polymer_system.chem_pot_dict[species] += cp.log(polymer_system.salt_concs[species])\n        else:\n            print(\"Bad Species:\", species)\n</code></pre>"},{"location":"observables/#polycomp.observables.get_free_energy","title":"<code>get_free_energy(polymer_system, E)</code>","text":"<p>Function to compute the free energy of the system.</p> <p>Parameters:</p> Name Type Description Default <code>E</code> <code>float</code> <p>The scaled Bjerrum length for the system.</p> required <p>Returns:</p> Name Type Description <code>total_free_energy</code> <code>float</code> <p>The total free energy of the system.</p> Source code in <code>polycomp/observables.py</code> <pre><code>def get_free_energy(polymer_system, E):\n    \"\"\"\n    Function to compute the free energy of the system.\n\n    Parameters:\n        E (float):\n            The scaled Bjerrum length for the system.\n\n    Returns:\n        total_free_energy (float):\n            The total free energy of the system.\n    \"\"\"\n\n    polymer_system.update_normal_from_density()\n    # initialize free energy array\n    free_energy = cp.zeros_like(polymer_system.normal_w[0])\n    mu_energy = 0\n\n    # mu squared terms\n    for i in range(polymer_system.normal_w.shape[0]):\n        free_energy += -(1 / (2 * polymer_system.normal_evalues[i])) * cp.square(\n            polymer_system.normal_w[i]\n        )\n\n    # psi term\n    psi_k = cufft.fftn(polymer_system.psi)\n    grad_psi_k = psi_k * 1j * polymer_system.grid.k1\n    grad_psi = cufft.ifftn(grad_psi_k, s=psi_k.shape)\n\n    free_energy += cp.abs(grad_psi) ** 2 / (2 * E)\n\n    total_free_energy = cp.sum(free_energy) * polymer_system.grid.dV\n\n    # Partition energy contribution\n    partition_energy = 0.0\n\n    ig_entropy = 0.0\n    species_partition = {}\n    for species in polymer_system.Q_dict:\n        if species in polymer_system.poly_dict:\n            partition_energy -= (\n                polymer_system.poly_dict[species] * polymer_system.grid.V * cp.log(polymer_system.Q_dict[species])\n            )\n            species_partition[species] = (\n                -polymer_system.poly_dict[species]\n                * polymer_system.grid.V\n                * cp.log(polymer_system.Q_dict[species])\n            )\n            # Ideal gas entropy contribution\n            ig_entropy += (\n                polymer_system.poly_dict[species]\n                * polymer_system.grid.V\n                * (cp.log(polymer_system.poly_dict[species]) - 1)\n            )\n        elif species in polymer_system.solvent_dict:\n            partition_energy -= (\n                polymer_system.solvent_dict[species]\n                * polymer_system.grid.V\n                * cp.log(polymer_system.Q_dict[species])\n            )\n            species_partition[species] = (\n                -polymer_system.solvent_dict[species]\n                * polymer_system.grid.V\n                * cp.log(polymer_system.Q_dict[species])\n            )\n            # Ideal gas entropy contribution\n            ig_entropy += (\n                polymer_system.solvent_dict[species]\n                * polymer_system.grid.V\n                * (cp.log(polymer_system.solvent_dict[species]) - 1)\n            )\n        elif species in polymer_system.salts:\n            salt_conc = polymer_system.salt_concs[species]\n            partition_energy -= (\n                salt_conc * polymer_system.grid.V * cp.log(polymer_system.Q_dict[species])\n            )\n            species_partition[species] = (\n                -salt_conc * polymer_system.grid.V * cp.log(polymer_system.Q_dict[species])\n            )\n            # Ideal gas entropy contribution\n            ig_entropy += salt_conc * polymer_system.grid.V * (cp.log(salt_conc) - 1)\n        else:\n            print(\"Bad Species:\", species)\n            raise ValueError(\"Couldn't find species in any dictionary\")\n    total_free_energy += partition_energy + ig_entropy\n\n    avg_conc = cp.average(\n        polymer_system.reduce_phi_all(polymer_system.phi_all), axis=range(1, polymer_system.phi_all.ndim)\n    )\n\n    # Free energy from homogeneous case (needed for comparing across conditions in\n    # gibbs ensemble and others)\n    total_free_energy += (\n        (avg_conc @ polymer_system.red_FH_mat @ avg_conc).real * polymer_system.grid.V / 2\n    )\n    return total_free_energy\n</code></pre>"},{"location":"observables/#polycomp.observables.get_pressure","title":"<code>get_pressure(polymer_system)</code>","text":"<p>Function to compute the pressure of the system.</p> <p>Returns:</p> Name Type Description <code>pressure</code> <code>float</code> <p>Pressure of the system.</p> Source code in <code>polycomp/observables.py</code> <pre><code>def get_pressure(polymer_system):\n    \"\"\"\n    Function to compute the pressure of the system.\n\n    Returns:\n        pressure (float):\n            Pressure of the system.\n    \"\"\"\n\n    # since the ideal mixture terms are extensive but their underlying\n    # functions don't (or weakly, depending on construction) depend on volume we will use their\n    # values divided by volume to get their contribution to pressure\n    # TODO: functionalize this, it is used multiple times\n    ideal_contribution = 0j\n    Q_contribution = 0j\n\n    avg_conc = cp.average(\n        polymer_system.reduce_phi_all(polymer_system.phi_all), axis=range(1, polymer_system.phi_all.ndim)\n    )\n\n    ideal_contribution += (avg_conc @ polymer_system.red_FH_mat @ avg_conc).real / 2\n    for poly in polymer_system.poly_dict:\n        ideal_contribution += polymer_system.poly_dict[poly]\n        Q_contribution += polymer_system.dQ_dV_dict[poly]\n    for sol in polymer_system.solvent_dict:\n        ideal_contribution += polymer_system.solvent_dict[sol]\n        Q_contribution += polymer_system.dQ_dV_dict[sol]\n    if polymer_system.use_salts:\n        polymer_system.get_salt_concs()\n        for salt in polymer_system.salts:\n            ideal_contribution += polymer_system.salt_concs[salt]\n            Q_contribution += polymer_system.dQ_dV_dict[salt]\n\n    # TODO: Add salt\n    # in the alternative formulation we only need the partition function terms\n    # differs slightly from Villet because we need to solve segment by\n    # segment, but we will offload this into the density operator\n    pressure = ideal_contribution + Q_contribution\n\n    return pressure\n</code></pre>"},{"location":"observables/#polycomp.observables.get_structure_factor","title":"<code>get_structure_factor(grid, real_dens, for_pair_corr=False)</code>","text":"<p>Calculate the structure factor of a density grid.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>Grid</code> <p>The grid object.</p> required <code>real_dens</code> <code>cparray</code> <p>The density grid.</p> required <code>for_pair_corr</code> <code>bool</code> <p>If True, return the structure factor without averaging over shells.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>struct_dists</code> <code>cparray</code> <p>The distances of the shells.</p> <code>s_fact_1d</code> <code>cparray</code> <p>The structure factor averaged over shells.</p> <code>s_fact_2d</code> <code>cparray</code> <p>The structure factor without averaging over shells.</p> Source code in <code>polycomp/observables.py</code> <pre><code>def get_structure_factor(grid, real_dens, for_pair_corr=False):\n    \"\"\"\n    Calculate the structure factor of a density grid.\n\n    Parameters:\n        grid (Grid):\n            The grid object.\n        real_dens (cparray):\n            The density grid.\n        for_pair_corr (bool):\n            If True, return the structure factor without averaging over shells.\n\n    Returns:\n        struct_dists (cparray):\n            The distances of the shells.\n        s_fact_1d (cparray):\n            The structure factor averaged over shells.\n        s_fact_2d (cparray):\n            The structure factor without averaging over shells.\n    \"\"\"\n\n    # Normalize Densities\n    work_dens = real_dens.real / cp.average(real_dens.real)\n    s_fact_2d = cp.zeros_like(work_dens)\n    wheres = cp.unique(grid.k2)[1::]\n    s_fact_1d = cp.zeros(wheres.size)\n\n    # Calculate the structure factor\n    phi_k = cufft.fftn(work_dens, s=work_dens.shape)\n    s_fact_2d = cp.abs(phi_k) ** 2 * cp.average(real_dens.real) + 1\n    if for_pair_corr is True:\n        return s_fact_2d\n\n    struct_dists = wheres ** (0.5)\n\n    # Average over shells\n    # TODO: Allow for user set binning\n    num_bins = wheres.size // 5\n    bins = cp.linspace(cp.amin(wheres), cp.amax(wheres), num=num_bins + 1)\n    where_bins = bins[:-1] + (bins[1] - bins[0]) / 2\n    locations = cp.digitize(grid.k2, bins)\n    s_fact_1d = cp.zeros(where_bins.size)\n\n    for i in range(where_bins.size):\n        s_fact_1d[i] = cp.average(s_fact_2d[locations == i])\n    struct_dists = where_bins ** (0.5)\n\n    return struct_dists, s_fact_1d, s_fact_2d\n</code></pre>"},{"location":"observables/#polycomp.observables.pair_correlation","title":"<code>pair_correlation(grid, real_dens)</code>","text":"<p>Calculate the pair correlation function of a density grid.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>Grid</code> <p>The grid object.</p> required <code>real_dens</code> <code>cparray</code> <p>The density grid.</p> required <p>Returns:</p> Name Type Description <code>where_bins</code> <code>cparray</code> <p>The distances of the shells.</p> <code>g_1d</code> <code>cparray</code> <p>The pair correlation function averaged over shells.</p> <code>g_2d</code> <code>cparray</code> <p>The pair correlation function without averaging over shells.</p> Source code in <code>polycomp/observables.py</code> <pre><code>def pair_correlation(grid, real_dens):\n    \"\"\"\n    Calculate the pair correlation function of a density grid.\n\n    Parameters:\n        grid (Grid):\n            The grid object.\n        real_dens (cparray):\n            The density grid.\n\n    Returns:\n        where_bins (cparray):\n            The distances of the shells.\n        g_1d (cparray):\n            The pair correlation function averaged over shells.\n        g_2d (cparray):\n            The pair correlation function without averaging over shells.\n    \"\"\"\n\n    s2d = get_structure_factor(grid, real_dens, for_pair_corr=True)\n    rho = cp.average(real_dens)\n    disps = cp.sqrt(cp.sum(grid.grid**2, axis=0))\n\n    g_2d = cufft.ifftn((s2d - 1), s=s2d.shape).real / (rho * real_dens.size)\n\n    wheres = cp.unique(disps)[1::]\n\n    # TODO: Allow for user set binning\n    num_bins = wheres.size // 800\n    bins = cp.linspace(cp.amin(wheres), cp.amax(wheres), num=num_bins + 1)\n    where_bins = bins[:-1] + (bins[1] - bins[0]) / 2\n    locations = cp.digitize(disps, bins)\n    g_1d = cp.zeros(where_bins.size)\n\n    for i in range(where_bins.size):\n        g_1d[i] = cp.average(g_2d[locations == i])\n\n    return where_bins, g_1d, g_2d\n</code></pre>"},{"location":"polymersystem/","title":"Polymer System","text":"<p>Main core part of the program. This controls the setup for many of the parameters actually needed to run integration schemes, manages the polymer architecture and  contains the functions required to get species partition functions and densities.</p>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem","title":"<code>PolymerSystem</code>","text":"<p>             Bases: <code>object</code></p> <p>Polymer system that is used to store and conduct most of the operations associated with a specific configuration.</p> <p>Attributes:</p> Name Type Description <code>n_species</code> <code>int</code> <p>Number of monomer species in simulation.</p> <code>integration_width</code> <code>float</code> <p>Maximum integration width along the polymer.</p> <code>FH_dict</code> <code>dict</code> <p>Dict of frozenset(Monomer object):float representing the interaction potentials between all possible pairs of monomers.</p> <code>polymers</code> <code>tuple</code> <p>List of Polymer objects representing all polymers in the system.</p> <code>poly_dict</code> <code>dict</code> <p>Dict of Polymer objects representing the amount of each polymer in solution.</p> <code>solvent_dict</code> <code>dict</code> <p>Dict of Monomer objects representing the amount of each solvent species in solution.</p> <code>Q_dict</code> <code>dict</code> <p>Dict for storing the Q values of each polymer and monomer during the density collection step.</p> <code>dQ_dV_dict</code> <code>dict</code> <p>Dict for storing the dQ/dV values of each polymer and monomer for pressure calculations.</p> <code>FH_matrix</code> <code>cparray</code> <p>CPArray of floats representing the interaction potentials between all species.</p> <code>grid</code> <code>Grid object</code> <p>Grid object for the simulation.</p> <code>w_all</code> <code>cparray</code> <p>CPArray of complex128 representing the chemical potential field for each monomer species at every grid point in the real density representation.</p> <code>normal_w</code> <code>cparray</code> <p>CPArray of complex128 representing the chemical potential field at each grid point for fields in the normal mode representation.</p> <code>psi</code> <code>cparray</code> <p>CPArray of floats representing the electrostatic potential at each grid point.</p> <code>smear_const</code> <code>float</code> <p>Smearing constant for the simulation.</p> <code>monomers</code> <code>tuple</code> <p>Tuple of Monomer objects with an ordered representation of monomers.</p> <code>red_FH_mat</code> <code>cparray</code> <p>FH matrix with degenerate modes removed.</p> <code>degen_dict</code> <code>dict</code> <p>Dictionary mapping the identical species in the non-degenerate representation to their equivalents in the degenerate representation.</p> <code>rev_degen_dict</code> <code>dict</code> <p>Dict listing the indices of species in the non-degenerate representation given their degenerate representation.</p> <code>normal_evalues</code> <code>cparray</code> <p>CPArray of floats representing the eigenvalues of the normal mode decomposition.</p> <code>normal_modes</code> <code>cparray</code> <p>CPArray of floats representing the matrix of eigenvalues of the normal mode decomposition.</p> <code>A_ij</code> <code>cparray</code> <p>Same as normal modes.</p> <code>A_inv</code> <code>cp array</code> <p>Inverse of A_ij.</p> <code>gamma</code> <code>cparray</code> <p>CPArray of complex128 with 1 for eigenvalues less than 1 and 1j for eigenvalues more than 1.</p> <code>phi_all</code> <code>cparray</code> <p>Density of each monomer species at every grid point in the real density representation.</p> <code>phi_salt</code> <code>cparray</code> <p>Density of each salt species at every grid point in the real density.</p> <code>has_nanps</code> <code>bool</code> <p>True if there are nanoparticles in the system.</p> <code>N</code> <code>float</code> <p>Characteristic length of the system.</p> <code>use_salts</code> <code>bool</code> <p>True if there are salts in the system.</p> <code>ordered_spec</code> <code>tuple</code> <p>Tuple of species in the order they are stored in the density matrix.</p> <code>c_s</code> <code>float</code> <p>Total salt concentration.</p> <code>chem_pot_dict</code> <code>dict</code> <p>Dict of complex128 representing the chemical potential of each species.</p> Source code in <code>polycomp/ft_system.py</code> <pre><code>class PolymerSystem(object):\n    \"\"\"\n    Polymer system that is used to store and conduct most of the operations\n    associated with a specific configuration.\n\n    Attributes:\n        n_species (int):\n            Number of monomer species in simulation.\n        integration_width (float):\n            Maximum integration width along the polymer.\n        FH_dict (dict):\n            Dict of frozenset(Monomer object):float representing the interaction\n            potentials between all possible pairs of monomers.\n        polymers (tuple):\n            List of Polymer objects representing all polymers in the system.\n        poly_dict (dict):\n            Dict of Polymer objects representing the amount of each polymer\n            in solution.\n        solvent_dict (dict):\n            Dict of Monomer objects representing the amount of each solvent\n            species in solution.\n        Q_dict (dict):\n            Dict for storing the Q values of each polymer and monomer during the\n            density collection step.\n        dQ_dV_dict (dict):\n            Dict for storing the dQ/dV values of each polymer and monomer for pressure\n            calculations.\n        FH_matrix (cparray):\n            CPArray of floats representing the interaction potentials between all\n            species.\n        grid (Grid object):\n            Grid object for the simulation.\n        w_all (cparray):\n            CPArray of complex128 representing the chemical potential field for\n            each monomer species at every grid point in the real density\n            representation.\n        normal_w (cparray):\n            CPArray of complex128 representing the chemical potential field at\n            each grid point for fields in the normal mode representation.\n        psi (cparray):\n            CPArray of floats representing the electrostatic potential at each grid point.\n        smear_const (float):\n            Smearing constant for the simulation.\n        monomers (tuple):\n            Tuple of Monomer objects with an ordered representation of monomers.\n        red_FH_mat (cparray):\n            FH matrix with degenerate modes removed.\n        degen_dict (dict):\n            Dictionary mapping the identical species in the non-degenerate\n            representation to their equivalents in the degenerate representation.\n        rev_degen_dict (dict):\n            Dict listing the indices of species in the non-degenerate representation\n            given their degenerate representation.\n        normal_evalues (cparray):\n            CPArray of floats representing the eigenvalues of the normal mode\n            decomposition.\n        normal_modes (cparray):\n            CPArray of floats representing the matrix of eigenvalues of the normal\n            mode decomposition.\n        A_ij (cparray):\n            Same as normal modes.\n        A_inv (cp array):\n            Inverse of A_ij.\n        gamma (cparray):\n            CPArray of complex128 with 1 for eigenvalues less than 1 and 1j for\n            eigenvalues more than 1.\n        phi_all (cparray):\n            Density of each monomer species at every grid point in the real density\n            representation.\n        phi_salt (cparray):\n            Density of each salt species at every grid point in the real density.\n        has_nanps (bool):\n            True if there are nanoparticles in the system.\n        N (float):\n            Characteristic length of the system.\n        use_salts (bool):\n            True if there are salts in the system.\n        ordered_spec (tuple):\n            Tuple of species in the order they are stored in the density matrix.\n        c_s (float):\n            Total salt concentration.\n        chem_pot_dict (dict):\n            Dict of complex128 representing the chemical potential of each species.\n    \"\"\"\n\n    def __init__(\n        self,\n        monomers,\n        polymers,\n        spec_dict,\n        FH_dict,\n        grid,\n        smear_const,\n        salt_conc=0.0,\n        integration_width=4,\n        custom_salts=None,\n        nanoparticles=None,\n    ):\n        \"\"\"\n        Initialize polymer system.\n\n        Parameters:\n            monomers (list/tuple):\n                List of monomer species.\n            polymers (list/tuple):\n                List of polymer species.\n            spec_dict (dict):\n                Dict listing the amount of each polymer and solvent species in solution.\n            FH_dict (dict):\n                Dict corresponding each pair of frozenset of two monomers and their\n                FH interaction term.\n            grid (Grid object):\n                Grid object for the simulation.\n            smear_const (float):\n                Gaussian smearing constant.\n            salt_conc (float):\n                Total salt concentration, default 0.0.\n            integration_width (float):\n                Maximum integration width, default 4.\n            custom_salts (list/tuple):\n                List of salt species, default None leads to salts with charge +/- 1.\n            nanoparticles (list/tuple):\n                List of nanoparticle species, default None.\n\n        Raises:\n            ValueError:\n                Raised if there is a species that is not a polymer or monomer in\n                the species dictionary.\n        \"\"\"\n\n        super(PolymerSystem, self).__init__()\n\n        # add grid\n        self.grid = grid\n        self.n_species = len(monomers)\n        self.FH_dict = FH_dict\n\n        # we want the last monomer species to be solvent if possible\n        self.set_monomer_order(monomers)\n\n        # sort the species dictionary into polymer and solvent components\n        self.polymers = polymers\n        self.poly_dict = {}\n        self.solvent_dict = {}\n        self.Q_dict = {}\n\n        self.has_nanps = False\n        if nanoparticles is not None:\n            self.nanps = nanoparticles\n            self.has_nanps = True\n\n        # Makes sure everything is a polymer or a monomer and checks the total\n        # density\n        check_frac = 0\n        for spec in spec_dict.keys():\n            check_frac += spec_dict[spec]\n            if spec.__class__.__name__ == \"Polymer\":\n                self.poly_dict[spec] = spec_dict[spec]\n            elif spec.__class__.__name__ == \"Monomer\":\n                self.solvent_dict[spec] = spec_dict[spec]\n            else:\n                raise ValueError(\"Unknown member of species dictionary\")\n\n        # The longest species in the mix is designated as having length of N\n        self.N = max([x.total_length for x in self.poly_dict.keys()])\n        self.integration_width = integration_width\n\n        for poly in self.poly_dict.keys():\n            poly.total_length = poly.total_length\n\n        # build flory huggins matrix\n        self.FH_matrix = cp.zeros((self.n_species, self.n_species))\n\n        for i in range(len(self.monomers)):\n            for j in range(len(self.monomers)):\n                self.FH_matrix[i, j] = self.FH_dict[\n                    frozenset((monomers[i], monomers[j]))\n                ]\n\n        # write the actual integration frameworks to each polymer\n        for polymer in self.poly_dict:\n            polymer.build_working_polymer(\n                self.integration_width, polymer.total_length / self.N\n            )\n\n        # Check for degeneracies in representation and correct if necessary\n        self.find_degeneracy()\n\n        # generate FH matrix and find normal modes / eigenvalues\n        self.assign_normals()\n        self.get_gamma()\n\n        self.A_inv = cp.linalg.inv(self.A_ij)\n        size = len(self.normal_evalues)\n        hold = cp.zeros((size, size))\n        for i in range(size):\n            hold[i, i] = self.normal_evalues[i]\n\n        # Initialize all fields (currently to zero)\n        self.w_all = cp.zeros(\n            [self.red_FH_mat.shape[0]] + list(self.grid.k2.shape),\n            dtype=complex,\n        )\n        self.psi = cp.zeros_like(self.grid.k2, dtype=complex)\n\n        # Initialize mu field\n        self.update_normal_from_density()\n        self.smear_const = smear_const\n\n        # set a canonical ordering for the species (helpful for gibbs ensemble)\n        canonical_ordering = []\n        for species in spec_dict.keys():\n            canonical_ordering.append(species)\n        if abs(salt_conc) == 0:\n            self.use_salts = False\n            self.ordered_spec = tuple(canonical_ordering)\n            return\n        self.use_salts = True\n        self.c_s = salt_conc\n        if custom_salts is None:\n            self.salt_pos = Monomer(\"salt+\", 1, identity=\"salt\", has_volume=False)\n            self.salt_neg = Monomer(\"salt-\", -1, identity=\"salt\", has_volume=False)\n            self.salts = (self.salt_pos, self.salt_neg)\n        else:\n            self.salts = custom_salts\n        if len(self.salts) not in (0, 2):\n            raise NotImplentedError(\"Unusual number of salts\")\n\n        # Fix the ordering\n        for salt in self.salts:\n            canonical_ordering.append(salt)\n        self.ordered_spec = tuple(canonical_ordering)\n\n        return\n\n    def set_monomer_order(self, monomers):\n        \"\"\"\n        Permanently affixes the order of the monomers.\n\n        Orders the monomers so that solvents tend to be last and then writes\n        them into a tuple.\n\n        Parameters:\n            monomers (list):\n                List of Monomer objects to be ordered.\n        \"\"\"\n\n        forward_count = 0\n        reverse_count = len(monomers) - 1\n        temp_list = monomers.copy()\n        for monomer in monomers:\n            if monomer.identity == \"solvent\":\n                temp_list[reverse_count] = monomer\n                reverse_count -= 1\n            else:\n                temp_list[forward_count] = monomer\n                forward_count += 1\n        self.monomers = tuple(temp_list)\n        return\n\n    def find_degeneracy(self):\n        \"\"\"\n        Function to identify and combine degenerate species.\n\n        Any species that have identical FH parameters need to be combined and\n        operated on by a single chemical potential field. This function\n        identifies them, combines them, and then creates the dictionaries needed\n        to map in and out of the non-degenerate representation as needed.\n\n        Raises:\n            ValueError:\n                If the degeneracy cannot be reduced (usually caused by more complicated\n                degeneracies than just identical FH parameters).\n        \"\"\"\n\n        # Only works if two components have identical FH parameters (for now)\n        # TODO: probably can rewrite this to handle cases where two parameters\n        # are scaled or linear combinations but that would require more work\n\n        # WARNING: IS NOT GUARANTEED TO REMOVE ALL DEGENERACIES JUST EASY ONES\n        degen_sets = []\n        # identify degeneracy\n        for i in range(self.FH_matrix.shape[0]):\n            for j in range(i + 1, self.FH_matrix.shape[0]):\n                if np.allclose(self.FH_matrix[i], self.FH_matrix[j]):\n                    degen_sets.append({i, j})\n        reducing = True\n\n        # Horrible code to combine the degeneracies\n        while reducing:\n            reducing = False\n            return_to_outer_loop = False\n            for i in range(len(degen_sets)):\n                if return_to_outer_loop == True:\n                    break\n                for j in range(i + 1, len(degen_sets)):\n                    if len(degen_sets[i].union(degen_sets[j])) != len(\n                        degen_sets[i]\n                    ) + len(degen_sets[j]):\n                        return_to_outer_loop = True\n                        reducing = True\n                        degen_sets.append(degen_sets[i].union(degen_sets[j]))\n                        degen_sets.pop(i)\n                        degen_sets.pop(j)\n                        break\n\n        degen_lists = [sorted(x) for x in degen_sets]\n        # generate new non-degenerate matrix:\n        mask = np.ones(self.FH_matrix.shape[0], bool)\n        # generate non-degenerate FH matrix\n        for x in degen_lists:\n            mask[x[1:]] = 0\n        kept_indices = np.arange(len(mask))[mask]\n        self.red_FH_mat = self.FH_matrix[kept_indices][:, kept_indices]\n        # write a dictionary to record the new indices of the FH matrix to the\n        # original species\n        self.degen_dict = {}\n        self.rev_degen_dict = {}\n        for i in range(kept_indices.size):\n            modified = False\n            for degen in degen_lists:\n                if kept_indices[i] in degen:\n                    modified = True\n                    self.degen_dict[i] = [self.monomers[k] for k in degen]\n                    for j in degen:\n                        self.rev_degen_dict[self.monomers[j]] = i\n            if modified == False:\n                self.degen_dict[i] = [self.monomers[kept_indices[i]]]\n                self.rev_degen_dict[self.monomers[kept_indices[i]]] = i\n        if cp.linalg.det(self.red_FH_mat) == 0:\n            raise ValueError(\n                \"The Flory-Huggins matrix is still singular after degeneracy removal\"\n            )\n        return\n\n    def remove_degeneracy(self, array):\n        \"\"\"\n        This function sums over degenerate elements.\n\n        In the real density representation, degenerate elements should often be\n        summed over, and this function does that.\n\n        Parameters:\n            array (cparray):\n                Array like w_all to have degenerate elements summed over. Must\n                be ordered the same way as w_all.\n        \"\"\"\n\n        fixed_array = cp.zeros(\n            [len(self.degen_dict)] + list(array.shape[1:]), dtype=complex\n        )\n\n        for i in range(fixed_array.shape[0]):\n            for mon in self.degen_dict[i]:\n                fixed_array[i] += array[self.monomers.index(mon)]\n        return fixed_array\n\n    def assign_normals(self):\n        \"\"\"\n        Assign the normal eigevnalues and eigenvectors\n\n        Takes a non-degenerate FH matrix and generates the corresponding normal\n        mode decomposition factors of A_ij and eigenvalues\n        \"\"\"\n        # assign coefficients for normal mode tranform\n        self.normal_evalues, self.normal_modes = cp.linalg.eigh(self.red_FH_mat)\n\n        idx = self.normal_evalues.argsort()[::-1]\n        self.normal_evalues = self.normal_evalues[idx]\n        self.normal_modes = self.normal_modes[:, idx]\n\n        warning_thresh = 1e-3 * cp.amax(cp.abs(self.normal_evalues))\n        if cp.amin(cp.abs(self.normal_evalues)) &lt;= warning_thresh:\n            danger = cp.amin(cp.abs(self.normal_evalues))\n            warnings.warn(\n                \"Minimum eigenvalue is \"\n                + \"{:.3}\".format(danger)\n                + \" which is very small and likely to cause problems\"\n            )\n\n        self.A_ij = self.normal_modes\n        self.A_inv = cp.linalg.inv(self.A_ij)\n\n        return\n\n    def get_gamma(self):\n        \"\"\"\n        Generates gamma from eigenvalues\n        \"\"\"\n        # determine which fields are real and imaginary and assign correct gamma\n        gamma = cp.zeros(self.normal_evalues.size, dtype=\"complex128\")\n        gamma += 1j * (self.normal_evalues &gt; 0)\n        gamma += cp.logical_not(self.normal_evalues &gt; 0)\n        self.gamma = gamma\n        return\n\n    def randomize_array(self, array, noise):\n        \"\"\"\n        Generate a random array.\n\n        Noise is Gaussian distributed around zero with a variance of noise.\n\n        Parameters:\n            array (cparray):\n                Array used to determine the shape of the output noise.\n            noise (float):\n                Variance of noise.\n        \"\"\"\n        array = cp.random.random_sample(size=array.shape) * noise + 0j\n        return array\n\n    def map_dens_from_norm(self, w_like_array):\n        \"\"\"\n        Map any array from real density to normal representation.\n\n        The first axis of w_like_array must be shaped like w_all's first axis.\n\n        Parameters:\n            w_like_array (cparray):\n                Array in real density space to be transformed.\n        \"\"\"\n\n        new_array = (w_like_array.T @ (self.A_inv.T).T).T\n        return new_array\n\n    def update_density_from_normal(self):\n        \"\"\"\n        Update w_all from normal_w\n        \"\"\"\n        self.w_all = self.map_dens_from_norm(self.normal_w)\n        return\n\n    def map_norm_from_dens(self, w_like_array):\n        \"\"\"\n        Map any array from normal to real density representation.\n\n        The first axis of w_like_array must be shaped like w_all's first axis.\n\n        Parameters:\n            w_like_array (cparray):\n                Array in normal space to be transformed.\n        \"\"\"\n\n        new_array2 = (w_like_array.T @ (self.A_ij)).T\n        return new_array2\n\n    def update_normal_from_density(self):\n        \"\"\"\n        Update normal_w from w_all\n        \"\"\"\n        # update the normal mode representation to match current real\n        # represenation\n        self.normal_w = self.map_norm_from_dens(self.w_all)\n        return\n\n    def reduce_phi_all(self, phi_all):\n        \"\"\"\n        Reduce phi_all to only the non-degenerate elements.\n\n        Parameters:\n            phi_all (cparray):\n                Array like phi_all to be reduced.\n        \"\"\"\n\n        red_phi_all = cp.zeros(\n            [len(self.degen_dict)] + list(phi_all.shape[1:]), dtype=complex\n        )\n        for i in range(red_phi_all.shape[0]):\n            for mon in self.degen_dict[i]:\n                red_phi_all[i] += phi_all[self.monomers.index(mon)]\n        return red_phi_all\n\n    def convolve(self, array, kernel_k):\n        \"\"\"\n        Convolve any array with a given kernel.\n\n        The kernel is in k-space, and the array is in real space, uses a cupy C kernel.\n\n        Parameters:\n            array (cparray):\n                Real space array to be convolved.\n            kernel_k (cparray):\n                Kernel of the same last dimensions in k-space.\n        \"\"\"\n\n        # standard FFT\n        array_k = cufft.fftn(array, s=array.shape)\n\n        # More efficient convolution kernels than default cp\n        if kernel_k.dtype == \"float64\":\n            kernel_mult = kernel_mult_float\n        elif kernel_k.dtype == \"complex128\":\n            kernel_mult = kernel_mult_complex\n\n        # multiply kernel with array\n        conv_k = kernel_mult(array_k, kernel_k)\n\n        # Inverse transform\n        conv = cufft.ifftn(conv_k, s=array.shape)\n\n        return conv\n\n    def gaussian_smear(self, array, alpha):\n        \"\"\"\n        Smear an array by a Gaussian pseudospectrally.\n\n        Parameters:\n            array (cparray):\n                Array to be smeared.\n            alpha (float):\n                Variance of Gaussian to be smeared by.\n        \"\"\"\n\n        # generate convolution kernel\n        gauss_k = cp.exp(-self.grid.k2 * alpha**2 / 2)\n\n        # convolve\n        array_r = self.convolve(array, gauss_k)\n        return array_r\n\n    def laplacian(self, array):\n        \"\"\"\n        Calculate the laplacian of an array pseudospectraly\n        \"\"\"\n\n        # internal gradient for species on the grid\n        lap_array = self.convolve(array, -self.grid.k2)\n        return lap_array\n\n    def get_net_saltless_charge(self):\n        \"\"\"\n        Get the net charge of the system without salt\n        \"\"\"\n        total_charge = 0\n        for poly in self.polymers:\n            charge_struct = (\n                cp.array([bead.charge for bead in poly.struct]) * poly.h_struct\n            )\n            total_charge += cp.sum(charge_struct) * self.poly_dict[poly] * self.grid.V\n        return total_charge\n\n    def get_total_charge(self, include_salt=True):\n        \"\"\"\n        Get the total charge of the system.\n\n        Parameters:\n            include_salt (bool):\n                Whether to include salt in the total charge.\n        \"\"\"\n\n        total_charge = cp.zeros_like(self.psi)\n        for i in range(len(self.monomers)):\n            total_charge += self.monomers[i].charge * self.phi_all[i]\n\n        # Break out now if no salts\n        if include_salt == False or self.use_salts == False:\n            return total_charge\n\n        for i in range(len(self.salts)):\n            total_charge += self.salts[i].charge * self.phi_salt[i]\n        return total_charge\n\n    def get_densities(self, for_pressure=False):\n        \"\"\"\n        Function to get the densities from a given set of potentials.\n\n        Uses all of the configurations in the polysystem to determine the\n        integration scheme.\n\n        Parameters:\n            for_pressure (bool):\n                Whether to calculate the densities for pressure calculation, defaults to False.\n\n        Raises:\n            ValueError:\n                Raised if Q_c is not the same for all points along the polymer. This\n                is usually the case because either there is something wrong with\n                the integration plan or the fields have gone unstable and achieved\n                unphysical values.\n        \"\"\"\n\n        q_r0 = cp.ones_like(self.w_all[0])\n        q_r_dag0 = cp.ones_like(self.w_all[0])\n        self.phi_all = cp.zeros(\n            [len(self.rev_degen_dict)] + list(self.grid.k2.shape),\n            dtype=complex,\n        )\n\n        # build P_species from w_all and poly_list\n        P_species = {}\n        if for_pressure:\n            self.dQ_dV_dict = {}\n            self.dQ_dV_dict.clear()\n            P_press_species = {}\n            # Truly have no idea why this ndim term is here\n            gauss_12 = -cp.exp(-self.grid.k2 * self.smear_const**2 / 2) * (\n                self.grid.k2 * self.smear_const**2 / self.grid.ndims - 1 / (2)\n            )\n            gauss_16 = -cp.exp(-self.grid.k2 * self.smear_const**2 / 2) * (\n                self.grid.k2 * self.smear_const**2 / self.grid.ndims\n                - 1 / (2 * self.grid.ndims)\n            )\n\n        for monomer in self.monomers:\n            if monomer.has_volume:\n                # effective field from total of potentials\n                P_species[monomer] = self.gaussian_smear(\n                    self.w_all[self.rev_degen_dict[monomer]]\n                    + self.psi * monomer.charge,\n                    self.smear_const,\n                )\n                # This is the derivative smeared fields for each monomer type\n                if for_pressure:\n                    P_press_species[monomer] = self.convolve(\n                        self.w_all[self.rev_degen_dict[monomer]], gauss_12\n                    ) + self.convolve(self.psi * monomer.charge, gauss_16)\n        hold_phi_del_part = 0j\n        hold_dens_part = 0j\n        # Iterate over all polymer types\n        for polymer in self.poly_dict:\n            f_poly = self.poly_dict[polymer]\n            if f_poly == 0:\n                continue\n\n            # step size along polymer\n            if polymer.fastener is None:\n                q_r_s, q_r_dag_s = integrate_s(\n                    polymer.struct,\n                    polymer.h_struct,\n                    P_species,\n                    q_r0,\n                    q_r_dag0,\n                    self.grid,\n                )\n            else:\n                q_r_s, q_r_dag_s = integrate_s(\n                    polymer.struct,\n                    polymer.h_struct,\n                    P_species,\n                    q_r0,\n                    q_r_dag0,\n                    self.grid,\n                    fastener=polymer.fastener,\n                )\n            # Partition function as a function of s\n            Q_c = q_r_dag_s * q_r_s\n            Q_c = self.reindex_Q_c(Q_c)\n\n            # partition function across entire polymer\n            Q = (\n                cp.average(cp.sum(Q_c, axis=tuple(range(1, Q_c.ndim))))\n                * self.grid.dV\n                / self.grid.V\n            )\n            Q = cp.sum((Q_c)[0]) * self.grid.dV / self.grid.V\n\n            if for_pressure:\n                lap_q_r_s = cp.zeros_like(q_r_s)\n                for i in range(lap_q_r_s.shape[0]):\n                    lap_q_r_s[i] = self.laplacian(q_r_s[i])\n\n                Q_del_c = q_r_dag_s * lap_q_r_s\n                Q_del_c = self.reindex_Q_c(Q_del_c)\n\n                phi_del = cp.sum((Q_del_c.T * polymer.h_struct).T, axis=0) / Q\n                self.dQ_dV_dict[polymer] = (\n                    -f_poly\n                    * 2\n                    / self.grid.ndims\n                    * cp.sum(phi_del)\n                    * self.grid.dV\n                    / self.grid.V\n                )\n                hold_phi_del_part += (\n                    -f_poly\n                    * 2\n                    / self.grid.ndims\n                    * cp.sum(phi_del)\n                    * self.grid.dV\n                    / self.grid.V\n                )\n\n            # check that Q is equal across integral (necessary condition)\n            if not cp.allclose(\n                cp.sum(Q_c, axis=tuple(range(1, len(Q_c.shape))))\n                * self.grid.dV\n                / self.grid.V,\n                Q,\n            ):\n                print(cp.sum(Q_c, axis=tuple(range(Q_c.ndim - 1))))\n                raise ValueError(\"Q_c not equal across integral\")\n\n            self.Q_dict[polymer] = cp.copy(Q)\n\n            # generate phi's by summing over partition function in correct areas\n            for i in range(len(self.monomers)):\n                self.phi_all[i] += (\n                    cp.sum(\n                        (Q_c.T * polymer.h_struct).T[\n                            polymer.struct == self.monomers[i]\n                        ],\n                        axis=0,\n                    )\n                    * f_poly\n                    / (Q)\n                )\n                if for_pressure:\n                    self.dQ_dV_dict[polymer] += (\n                        cp.sum(\n                            cp.sum(\n                                (Q_c.T * polymer.h_struct).T[\n                                    polymer.struct == self.monomers[i]\n                                ],\n                                axis=0,\n                            )\n                            * f_poly\n                            / (Q)\n                            * P_press_species[self.monomers[i]]\n                        )\n                        * self.grid.dV\n                        / self.grid.V\n                    )\n                    hold_dens_part += (\n                        cp.sum(\n                            cp.sum(\n                                (Q_c.T * polymer.h_struct).T[\n                                    polymer.struct == self.monomers[i]\n                                ],\n                                axis=0,\n                            )\n                            * f_poly\n                            / (Q)\n                            * P_press_species[self.monomers[i]]\n                        )\n                        * self.grid.dV\n                        / self.grid.V\n                    )\n\n        # compute solvent densities\n        for solvent in self.solvent_dict:\n            idx = self.monomers.index(solvent)\n            exp_w_S = cp.exp(\n                -self.gaussian_smear(P_species[self.monomers[idx]], self.smear_const)\n                / self.N\n            )\n            Q_S = cp.sum(exp_w_S) / (self.grid.k2.size)\n            self.phi_all[idx] += exp_w_S * self.solvent_dict[solvent] / (self.N * Q_S)\n            self.Q_dict[solvent] = cp.copy(Q_S)\n            if for_pressure:\n                self.dQ_dV_dict[solvent] = (\n                    cp.sum(\n                        (exp_w_S * self.solvent_dict[solvent] / (self.N * Q_S))\n                        * P_press_species[solvent]\n                    )\n                    * self.grid.dV\n                    / self.grid.V\n                )\n\n        # check if we are using salts\n        if self.use_salts == False:\n            return\n\n        phi_salt_shape = list(self.w_all.shape)\n        phi_salt_shape[0] = 2\n        self.phi_salt = cp.zeros(phi_salt_shape, dtype=complex)\n\n        self.get_salt_concs()\n\n        for i in range(len(self.salts)):\n            if self.c_s == 0:\n                break\n\n            salt_conc = self.salt_concs[self.salts[i]]\n            w_salt = self.salts[i].charge * self.gaussian_smear(\n                self.psi, self.smear_const\n            )\n            exp_w_salt = cp.exp(-w_salt / self.N)\n            Q_salt = cp.sum(exp_w_salt) / (self.grid.k2.size)\n            self.phi_salt[i] = (exp_w_salt * salt_conc / (Q_salt)) / self.N\n            self.Q_dict[self.salts[i]] = Q_salt\n            if for_pressure:\n                # TODO: This I'm still unsure about this\n                w_press_salt = (\n                    self.salts[i].charge\n                    * self.convolve(self.psi, gauss_16)\n                    * self.salts[i].charge\n                )\n                self.dQ_dV_dict[self.salts[i]] = (\n                    cp.sum((exp_w_salt * salt_conc / (self.N * Q_salt)) * w_press_salt)\n                    * self.grid.dV\n                    / self.grid.V\n                )\n\n        if self.has_nanps:\n            for nanp in self.nanps:\n                idx = self.monomers.index(nanp.type)\n                dens = nanp.density * 1\n                self.phi_all[idx] += dens\n        return\n\n    def get_salt_concs(self):\n        \"\"\"\n        Computes the salt concentrations needed to correct the charge imbalance.\n\n        Raises:\n            ValueError:\n                Raised if the amount of total salt is not enough to correct the charge\n                imbalance.\n        \"\"\"\n\n        self.salt_concs = {}\n\n        net_saltless_charge = self.get_net_saltless_charge()\n\n        salt_charges = [salt.charge for salt in self.salts]\n        if (\n            net_saltless_charge &lt; self.c_s * self.grid.V * min(salt_charges) / self.N\n            or net_saltless_charge &gt; self.c_s * self.grid.V * max(salt_charges) / self.N\n        ):\n            print(\n                \"Salt needed is \",\n                abs(net_saltless_charge) / (self.grid.k2.size),\n            )\n            raise ValueError(\"Inadequate salt to correct charge imbalance\")\n\n        for salt in self.salts:\n            self.salt_concs[salt] = salt_conc = (\n                self.c_s - net_saltless_charge * self.N / (salt.charge * self.grid.V)\n            ) / 2\n\n    def reindex_Q_c(self, Q_c):\n        \"\"\"\n        Function to reindex Q_c to correctly handle edges of polymers.\n\n        Because the integration takes place over the polymer beads but the\n        values are recorded at the joints, we need to reindex the joints back\n        to the beads. This could also be used for more complicated integration\n        schemes later.\n\n        Parameters:\n            Q_c (cparray):\n                Q_c with a shape that is associated with the joints.\n        \"\"\"\n\n        shape = list(Q_c.shape)\n        shape[0] -= 1\n        new_Q_c = cp.zeros(shape, dtype=complex)\n        new_Q_c += Q_c[1:] / 2 + Q_c[:-1] / 2\n\n        return new_Q_c\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.__init__","title":"<code>__init__(monomers, polymers, spec_dict, FH_dict, grid, smear_const, salt_conc=0.0, integration_width=4, custom_salts=None, nanoparticles=None)</code>","text":"<p>Initialize polymer system.</p> <p>Parameters:</p> Name Type Description Default <code>monomers</code> <code>list / tuple</code> <p>List of monomer species.</p> required <code>polymers</code> <code>list / tuple</code> <p>List of polymer species.</p> required <code>spec_dict</code> <code>dict</code> <p>Dict listing the amount of each polymer and solvent species in solution.</p> required <code>FH_dict</code> <code>dict</code> <p>Dict corresponding each pair of frozenset of two monomers and their FH interaction term.</p> required <code>grid</code> <code>Grid object</code> <p>Grid object for the simulation.</p> required <code>smear_const</code> <code>float</code> <p>Gaussian smearing constant.</p> required <code>salt_conc</code> <code>float</code> <p>Total salt concentration, default 0.0.</p> <code>0.0</code> <code>integration_width</code> <code>float</code> <p>Maximum integration width, default 4.</p> <code>4</code> <code>custom_salts</code> <code>list / tuple</code> <p>List of salt species, default None leads to salts with charge +/- 1.</p> <code>None</code> <code>nanoparticles</code> <code>list / tuple</code> <p>List of nanoparticle species, default None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised if there is a species that is not a polymer or monomer in the species dictionary.</p> Source code in <code>polycomp/ft_system.py</code> <pre><code>def __init__(\n    self,\n    monomers,\n    polymers,\n    spec_dict,\n    FH_dict,\n    grid,\n    smear_const,\n    salt_conc=0.0,\n    integration_width=4,\n    custom_salts=None,\n    nanoparticles=None,\n):\n    \"\"\"\n    Initialize polymer system.\n\n    Parameters:\n        monomers (list/tuple):\n            List of monomer species.\n        polymers (list/tuple):\n            List of polymer species.\n        spec_dict (dict):\n            Dict listing the amount of each polymer and solvent species in solution.\n        FH_dict (dict):\n            Dict corresponding each pair of frozenset of two monomers and their\n            FH interaction term.\n        grid (Grid object):\n            Grid object for the simulation.\n        smear_const (float):\n            Gaussian smearing constant.\n        salt_conc (float):\n            Total salt concentration, default 0.0.\n        integration_width (float):\n            Maximum integration width, default 4.\n        custom_salts (list/tuple):\n            List of salt species, default None leads to salts with charge +/- 1.\n        nanoparticles (list/tuple):\n            List of nanoparticle species, default None.\n\n    Raises:\n        ValueError:\n            Raised if there is a species that is not a polymer or monomer in\n            the species dictionary.\n    \"\"\"\n\n    super(PolymerSystem, self).__init__()\n\n    # add grid\n    self.grid = grid\n    self.n_species = len(monomers)\n    self.FH_dict = FH_dict\n\n    # we want the last monomer species to be solvent if possible\n    self.set_monomer_order(monomers)\n\n    # sort the species dictionary into polymer and solvent components\n    self.polymers = polymers\n    self.poly_dict = {}\n    self.solvent_dict = {}\n    self.Q_dict = {}\n\n    self.has_nanps = False\n    if nanoparticles is not None:\n        self.nanps = nanoparticles\n        self.has_nanps = True\n\n    # Makes sure everything is a polymer or a monomer and checks the total\n    # density\n    check_frac = 0\n    for spec in spec_dict.keys():\n        check_frac += spec_dict[spec]\n        if spec.__class__.__name__ == \"Polymer\":\n            self.poly_dict[spec] = spec_dict[spec]\n        elif spec.__class__.__name__ == \"Monomer\":\n            self.solvent_dict[spec] = spec_dict[spec]\n        else:\n            raise ValueError(\"Unknown member of species dictionary\")\n\n    # The longest species in the mix is designated as having length of N\n    self.N = max([x.total_length for x in self.poly_dict.keys()])\n    self.integration_width = integration_width\n\n    for poly in self.poly_dict.keys():\n        poly.total_length = poly.total_length\n\n    # build flory huggins matrix\n    self.FH_matrix = cp.zeros((self.n_species, self.n_species))\n\n    for i in range(len(self.monomers)):\n        for j in range(len(self.monomers)):\n            self.FH_matrix[i, j] = self.FH_dict[\n                frozenset((monomers[i], monomers[j]))\n            ]\n\n    # write the actual integration frameworks to each polymer\n    for polymer in self.poly_dict:\n        polymer.build_working_polymer(\n            self.integration_width, polymer.total_length / self.N\n        )\n\n    # Check for degeneracies in representation and correct if necessary\n    self.find_degeneracy()\n\n    # generate FH matrix and find normal modes / eigenvalues\n    self.assign_normals()\n    self.get_gamma()\n\n    self.A_inv = cp.linalg.inv(self.A_ij)\n    size = len(self.normal_evalues)\n    hold = cp.zeros((size, size))\n    for i in range(size):\n        hold[i, i] = self.normal_evalues[i]\n\n    # Initialize all fields (currently to zero)\n    self.w_all = cp.zeros(\n        [self.red_FH_mat.shape[0]] + list(self.grid.k2.shape),\n        dtype=complex,\n    )\n    self.psi = cp.zeros_like(self.grid.k2, dtype=complex)\n\n    # Initialize mu field\n    self.update_normal_from_density()\n    self.smear_const = smear_const\n\n    # set a canonical ordering for the species (helpful for gibbs ensemble)\n    canonical_ordering = []\n    for species in spec_dict.keys():\n        canonical_ordering.append(species)\n    if abs(salt_conc) == 0:\n        self.use_salts = False\n        self.ordered_spec = tuple(canonical_ordering)\n        return\n    self.use_salts = True\n    self.c_s = salt_conc\n    if custom_salts is None:\n        self.salt_pos = Monomer(\"salt+\", 1, identity=\"salt\", has_volume=False)\n        self.salt_neg = Monomer(\"salt-\", -1, identity=\"salt\", has_volume=False)\n        self.salts = (self.salt_pos, self.salt_neg)\n    else:\n        self.salts = custom_salts\n    if len(self.salts) not in (0, 2):\n        raise NotImplentedError(\"Unusual number of salts\")\n\n    # Fix the ordering\n    for salt in self.salts:\n        canonical_ordering.append(salt)\n    self.ordered_spec = tuple(canonical_ordering)\n\n    return\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.assign_normals","title":"<code>assign_normals()</code>","text":"<p>Assign the normal eigevnalues and eigenvectors</p> <p>Takes a non-degenerate FH matrix and generates the corresponding normal mode decomposition factors of A_ij and eigenvalues</p> Source code in <code>polycomp/ft_system.py</code> <pre><code>def assign_normals(self):\n    \"\"\"\n    Assign the normal eigevnalues and eigenvectors\n\n    Takes a non-degenerate FH matrix and generates the corresponding normal\n    mode decomposition factors of A_ij and eigenvalues\n    \"\"\"\n    # assign coefficients for normal mode tranform\n    self.normal_evalues, self.normal_modes = cp.linalg.eigh(self.red_FH_mat)\n\n    idx = self.normal_evalues.argsort()[::-1]\n    self.normal_evalues = self.normal_evalues[idx]\n    self.normal_modes = self.normal_modes[:, idx]\n\n    warning_thresh = 1e-3 * cp.amax(cp.abs(self.normal_evalues))\n    if cp.amin(cp.abs(self.normal_evalues)) &lt;= warning_thresh:\n        danger = cp.amin(cp.abs(self.normal_evalues))\n        warnings.warn(\n            \"Minimum eigenvalue is \"\n            + \"{:.3}\".format(danger)\n            + \" which is very small and likely to cause problems\"\n        )\n\n    self.A_ij = self.normal_modes\n    self.A_inv = cp.linalg.inv(self.A_ij)\n\n    return\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.convolve","title":"<code>convolve(array, kernel_k)</code>","text":"<p>Convolve any array with a given kernel.</p> <p>The kernel is in k-space, and the array is in real space, uses a cupy C kernel.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>cparray</code> <p>Real space array to be convolved.</p> required <code>kernel_k</code> <code>cparray</code> <p>Kernel of the same last dimensions in k-space.</p> required Source code in <code>polycomp/ft_system.py</code> <pre><code>def convolve(self, array, kernel_k):\n    \"\"\"\n    Convolve any array with a given kernel.\n\n    The kernel is in k-space, and the array is in real space, uses a cupy C kernel.\n\n    Parameters:\n        array (cparray):\n            Real space array to be convolved.\n        kernel_k (cparray):\n            Kernel of the same last dimensions in k-space.\n    \"\"\"\n\n    # standard FFT\n    array_k = cufft.fftn(array, s=array.shape)\n\n    # More efficient convolution kernels than default cp\n    if kernel_k.dtype == \"float64\":\n        kernel_mult = kernel_mult_float\n    elif kernel_k.dtype == \"complex128\":\n        kernel_mult = kernel_mult_complex\n\n    # multiply kernel with array\n    conv_k = kernel_mult(array_k, kernel_k)\n\n    # Inverse transform\n    conv = cufft.ifftn(conv_k, s=array.shape)\n\n    return conv\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.find_degeneracy","title":"<code>find_degeneracy()</code>","text":"<p>Function to identify and combine degenerate species.</p> <p>Any species that have identical FH parameters need to be combined and operated on by a single chemical potential field. This function identifies them, combines them, and then creates the dictionaries needed to map in and out of the non-degenerate representation as needed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the degeneracy cannot be reduced (usually caused by more complicated degeneracies than just identical FH parameters).</p> Source code in <code>polycomp/ft_system.py</code> <pre><code>def find_degeneracy(self):\n    \"\"\"\n    Function to identify and combine degenerate species.\n\n    Any species that have identical FH parameters need to be combined and\n    operated on by a single chemical potential field. This function\n    identifies them, combines them, and then creates the dictionaries needed\n    to map in and out of the non-degenerate representation as needed.\n\n    Raises:\n        ValueError:\n            If the degeneracy cannot be reduced (usually caused by more complicated\n            degeneracies than just identical FH parameters).\n    \"\"\"\n\n    # Only works if two components have identical FH parameters (for now)\n    # TODO: probably can rewrite this to handle cases where two parameters\n    # are scaled or linear combinations but that would require more work\n\n    # WARNING: IS NOT GUARANTEED TO REMOVE ALL DEGENERACIES JUST EASY ONES\n    degen_sets = []\n    # identify degeneracy\n    for i in range(self.FH_matrix.shape[0]):\n        for j in range(i + 1, self.FH_matrix.shape[0]):\n            if np.allclose(self.FH_matrix[i], self.FH_matrix[j]):\n                degen_sets.append({i, j})\n    reducing = True\n\n    # Horrible code to combine the degeneracies\n    while reducing:\n        reducing = False\n        return_to_outer_loop = False\n        for i in range(len(degen_sets)):\n            if return_to_outer_loop == True:\n                break\n            for j in range(i + 1, len(degen_sets)):\n                if len(degen_sets[i].union(degen_sets[j])) != len(\n                    degen_sets[i]\n                ) + len(degen_sets[j]):\n                    return_to_outer_loop = True\n                    reducing = True\n                    degen_sets.append(degen_sets[i].union(degen_sets[j]))\n                    degen_sets.pop(i)\n                    degen_sets.pop(j)\n                    break\n\n    degen_lists = [sorted(x) for x in degen_sets]\n    # generate new non-degenerate matrix:\n    mask = np.ones(self.FH_matrix.shape[0], bool)\n    # generate non-degenerate FH matrix\n    for x in degen_lists:\n        mask[x[1:]] = 0\n    kept_indices = np.arange(len(mask))[mask]\n    self.red_FH_mat = self.FH_matrix[kept_indices][:, kept_indices]\n    # write a dictionary to record the new indices of the FH matrix to the\n    # original species\n    self.degen_dict = {}\n    self.rev_degen_dict = {}\n    for i in range(kept_indices.size):\n        modified = False\n        for degen in degen_lists:\n            if kept_indices[i] in degen:\n                modified = True\n                self.degen_dict[i] = [self.monomers[k] for k in degen]\n                for j in degen:\n                    self.rev_degen_dict[self.monomers[j]] = i\n        if modified == False:\n            self.degen_dict[i] = [self.monomers[kept_indices[i]]]\n            self.rev_degen_dict[self.monomers[kept_indices[i]]] = i\n    if cp.linalg.det(self.red_FH_mat) == 0:\n        raise ValueError(\n            \"The Flory-Huggins matrix is still singular after degeneracy removal\"\n        )\n    return\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.gaussian_smear","title":"<code>gaussian_smear(array, alpha)</code>","text":"<p>Smear an array by a Gaussian pseudospectrally.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>cparray</code> <p>Array to be smeared.</p> required <code>alpha</code> <code>float</code> <p>Variance of Gaussian to be smeared by.</p> required Source code in <code>polycomp/ft_system.py</code> <pre><code>def gaussian_smear(self, array, alpha):\n    \"\"\"\n    Smear an array by a Gaussian pseudospectrally.\n\n    Parameters:\n        array (cparray):\n            Array to be smeared.\n        alpha (float):\n            Variance of Gaussian to be smeared by.\n    \"\"\"\n\n    # generate convolution kernel\n    gauss_k = cp.exp(-self.grid.k2 * alpha**2 / 2)\n\n    # convolve\n    array_r = self.convolve(array, gauss_k)\n    return array_r\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.get_densities","title":"<code>get_densities(for_pressure=False)</code>","text":"<p>Function to get the densities from a given set of potentials.</p> <p>Uses all of the configurations in the polysystem to determine the integration scheme.</p> <p>Parameters:</p> Name Type Description Default <code>for_pressure</code> <code>bool</code> <p>Whether to calculate the densities for pressure calculation, defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised if Q_c is not the same for all points along the polymer. This is usually the case because either there is something wrong with the integration plan or the fields have gone unstable and achieved unphysical values.</p> Source code in <code>polycomp/ft_system.py</code> <pre><code>def get_densities(self, for_pressure=False):\n    \"\"\"\n    Function to get the densities from a given set of potentials.\n\n    Uses all of the configurations in the polysystem to determine the\n    integration scheme.\n\n    Parameters:\n        for_pressure (bool):\n            Whether to calculate the densities for pressure calculation, defaults to False.\n\n    Raises:\n        ValueError:\n            Raised if Q_c is not the same for all points along the polymer. This\n            is usually the case because either there is something wrong with\n            the integration plan or the fields have gone unstable and achieved\n            unphysical values.\n    \"\"\"\n\n    q_r0 = cp.ones_like(self.w_all[0])\n    q_r_dag0 = cp.ones_like(self.w_all[0])\n    self.phi_all = cp.zeros(\n        [len(self.rev_degen_dict)] + list(self.grid.k2.shape),\n        dtype=complex,\n    )\n\n    # build P_species from w_all and poly_list\n    P_species = {}\n    if for_pressure:\n        self.dQ_dV_dict = {}\n        self.dQ_dV_dict.clear()\n        P_press_species = {}\n        # Truly have no idea why this ndim term is here\n        gauss_12 = -cp.exp(-self.grid.k2 * self.smear_const**2 / 2) * (\n            self.grid.k2 * self.smear_const**2 / self.grid.ndims - 1 / (2)\n        )\n        gauss_16 = -cp.exp(-self.grid.k2 * self.smear_const**2 / 2) * (\n            self.grid.k2 * self.smear_const**2 / self.grid.ndims\n            - 1 / (2 * self.grid.ndims)\n        )\n\n    for monomer in self.monomers:\n        if monomer.has_volume:\n            # effective field from total of potentials\n            P_species[monomer] = self.gaussian_smear(\n                self.w_all[self.rev_degen_dict[monomer]]\n                + self.psi * monomer.charge,\n                self.smear_const,\n            )\n            # This is the derivative smeared fields for each monomer type\n            if for_pressure:\n                P_press_species[monomer] = self.convolve(\n                    self.w_all[self.rev_degen_dict[monomer]], gauss_12\n                ) + self.convolve(self.psi * monomer.charge, gauss_16)\n    hold_phi_del_part = 0j\n    hold_dens_part = 0j\n    # Iterate over all polymer types\n    for polymer in self.poly_dict:\n        f_poly = self.poly_dict[polymer]\n        if f_poly == 0:\n            continue\n\n        # step size along polymer\n        if polymer.fastener is None:\n            q_r_s, q_r_dag_s = integrate_s(\n                polymer.struct,\n                polymer.h_struct,\n                P_species,\n                q_r0,\n                q_r_dag0,\n                self.grid,\n            )\n        else:\n            q_r_s, q_r_dag_s = integrate_s(\n                polymer.struct,\n                polymer.h_struct,\n                P_species,\n                q_r0,\n                q_r_dag0,\n                self.grid,\n                fastener=polymer.fastener,\n            )\n        # Partition function as a function of s\n        Q_c = q_r_dag_s * q_r_s\n        Q_c = self.reindex_Q_c(Q_c)\n\n        # partition function across entire polymer\n        Q = (\n            cp.average(cp.sum(Q_c, axis=tuple(range(1, Q_c.ndim))))\n            * self.grid.dV\n            / self.grid.V\n        )\n        Q = cp.sum((Q_c)[0]) * self.grid.dV / self.grid.V\n\n        if for_pressure:\n            lap_q_r_s = cp.zeros_like(q_r_s)\n            for i in range(lap_q_r_s.shape[0]):\n                lap_q_r_s[i] = self.laplacian(q_r_s[i])\n\n            Q_del_c = q_r_dag_s * lap_q_r_s\n            Q_del_c = self.reindex_Q_c(Q_del_c)\n\n            phi_del = cp.sum((Q_del_c.T * polymer.h_struct).T, axis=0) / Q\n            self.dQ_dV_dict[polymer] = (\n                -f_poly\n                * 2\n                / self.grid.ndims\n                * cp.sum(phi_del)\n                * self.grid.dV\n                / self.grid.V\n            )\n            hold_phi_del_part += (\n                -f_poly\n                * 2\n                / self.grid.ndims\n                * cp.sum(phi_del)\n                * self.grid.dV\n                / self.grid.V\n            )\n\n        # check that Q is equal across integral (necessary condition)\n        if not cp.allclose(\n            cp.sum(Q_c, axis=tuple(range(1, len(Q_c.shape))))\n            * self.grid.dV\n            / self.grid.V,\n            Q,\n        ):\n            print(cp.sum(Q_c, axis=tuple(range(Q_c.ndim - 1))))\n            raise ValueError(\"Q_c not equal across integral\")\n\n        self.Q_dict[polymer] = cp.copy(Q)\n\n        # generate phi's by summing over partition function in correct areas\n        for i in range(len(self.monomers)):\n            self.phi_all[i] += (\n                cp.sum(\n                    (Q_c.T * polymer.h_struct).T[\n                        polymer.struct == self.monomers[i]\n                    ],\n                    axis=0,\n                )\n                * f_poly\n                / (Q)\n            )\n            if for_pressure:\n                self.dQ_dV_dict[polymer] += (\n                    cp.sum(\n                        cp.sum(\n                            (Q_c.T * polymer.h_struct).T[\n                                polymer.struct == self.monomers[i]\n                            ],\n                            axis=0,\n                        )\n                        * f_poly\n                        / (Q)\n                        * P_press_species[self.monomers[i]]\n                    )\n                    * self.grid.dV\n                    / self.grid.V\n                )\n                hold_dens_part += (\n                    cp.sum(\n                        cp.sum(\n                            (Q_c.T * polymer.h_struct).T[\n                                polymer.struct == self.monomers[i]\n                            ],\n                            axis=0,\n                        )\n                        * f_poly\n                        / (Q)\n                        * P_press_species[self.monomers[i]]\n                    )\n                    * self.grid.dV\n                    / self.grid.V\n                )\n\n    # compute solvent densities\n    for solvent in self.solvent_dict:\n        idx = self.monomers.index(solvent)\n        exp_w_S = cp.exp(\n            -self.gaussian_smear(P_species[self.monomers[idx]], self.smear_const)\n            / self.N\n        )\n        Q_S = cp.sum(exp_w_S) / (self.grid.k2.size)\n        self.phi_all[idx] += exp_w_S * self.solvent_dict[solvent] / (self.N * Q_S)\n        self.Q_dict[solvent] = cp.copy(Q_S)\n        if for_pressure:\n            self.dQ_dV_dict[solvent] = (\n                cp.sum(\n                    (exp_w_S * self.solvent_dict[solvent] / (self.N * Q_S))\n                    * P_press_species[solvent]\n                )\n                * self.grid.dV\n                / self.grid.V\n            )\n\n    # check if we are using salts\n    if self.use_salts == False:\n        return\n\n    phi_salt_shape = list(self.w_all.shape)\n    phi_salt_shape[0] = 2\n    self.phi_salt = cp.zeros(phi_salt_shape, dtype=complex)\n\n    self.get_salt_concs()\n\n    for i in range(len(self.salts)):\n        if self.c_s == 0:\n            break\n\n        salt_conc = self.salt_concs[self.salts[i]]\n        w_salt = self.salts[i].charge * self.gaussian_smear(\n            self.psi, self.smear_const\n        )\n        exp_w_salt = cp.exp(-w_salt / self.N)\n        Q_salt = cp.sum(exp_w_salt) / (self.grid.k2.size)\n        self.phi_salt[i] = (exp_w_salt * salt_conc / (Q_salt)) / self.N\n        self.Q_dict[self.salts[i]] = Q_salt\n        if for_pressure:\n            # TODO: This I'm still unsure about this\n            w_press_salt = (\n                self.salts[i].charge\n                * self.convolve(self.psi, gauss_16)\n                * self.salts[i].charge\n            )\n            self.dQ_dV_dict[self.salts[i]] = (\n                cp.sum((exp_w_salt * salt_conc / (self.N * Q_salt)) * w_press_salt)\n                * self.grid.dV\n                / self.grid.V\n            )\n\n    if self.has_nanps:\n        for nanp in self.nanps:\n            idx = self.monomers.index(nanp.type)\n            dens = nanp.density * 1\n            self.phi_all[idx] += dens\n    return\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.get_gamma","title":"<code>get_gamma()</code>","text":"<p>Generates gamma from eigenvalues</p> Source code in <code>polycomp/ft_system.py</code> <pre><code>def get_gamma(self):\n    \"\"\"\n    Generates gamma from eigenvalues\n    \"\"\"\n    # determine which fields are real and imaginary and assign correct gamma\n    gamma = cp.zeros(self.normal_evalues.size, dtype=\"complex128\")\n    gamma += 1j * (self.normal_evalues &gt; 0)\n    gamma += cp.logical_not(self.normal_evalues &gt; 0)\n    self.gamma = gamma\n    return\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.get_net_saltless_charge","title":"<code>get_net_saltless_charge()</code>","text":"<p>Get the net charge of the system without salt</p> Source code in <code>polycomp/ft_system.py</code> <pre><code>def get_net_saltless_charge(self):\n    \"\"\"\n    Get the net charge of the system without salt\n    \"\"\"\n    total_charge = 0\n    for poly in self.polymers:\n        charge_struct = (\n            cp.array([bead.charge for bead in poly.struct]) * poly.h_struct\n        )\n        total_charge += cp.sum(charge_struct) * self.poly_dict[poly] * self.grid.V\n    return total_charge\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.get_salt_concs","title":"<code>get_salt_concs()</code>","text":"<p>Computes the salt concentrations needed to correct the charge imbalance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raised if the amount of total salt is not enough to correct the charge imbalance.</p> Source code in <code>polycomp/ft_system.py</code> <pre><code>def get_salt_concs(self):\n    \"\"\"\n    Computes the salt concentrations needed to correct the charge imbalance.\n\n    Raises:\n        ValueError:\n            Raised if the amount of total salt is not enough to correct the charge\n            imbalance.\n    \"\"\"\n\n    self.salt_concs = {}\n\n    net_saltless_charge = self.get_net_saltless_charge()\n\n    salt_charges = [salt.charge for salt in self.salts]\n    if (\n        net_saltless_charge &lt; self.c_s * self.grid.V * min(salt_charges) / self.N\n        or net_saltless_charge &gt; self.c_s * self.grid.V * max(salt_charges) / self.N\n    ):\n        print(\n            \"Salt needed is \",\n            abs(net_saltless_charge) / (self.grid.k2.size),\n        )\n        raise ValueError(\"Inadequate salt to correct charge imbalance\")\n\n    for salt in self.salts:\n        self.salt_concs[salt] = salt_conc = (\n            self.c_s - net_saltless_charge * self.N / (salt.charge * self.grid.V)\n        ) / 2\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.get_total_charge","title":"<code>get_total_charge(include_salt=True)</code>","text":"<p>Get the total charge of the system.</p> <p>Parameters:</p> Name Type Description Default <code>include_salt</code> <code>bool</code> <p>Whether to include salt in the total charge.</p> <code>True</code> Source code in <code>polycomp/ft_system.py</code> <pre><code>def get_total_charge(self, include_salt=True):\n    \"\"\"\n    Get the total charge of the system.\n\n    Parameters:\n        include_salt (bool):\n            Whether to include salt in the total charge.\n    \"\"\"\n\n    total_charge = cp.zeros_like(self.psi)\n    for i in range(len(self.monomers)):\n        total_charge += self.monomers[i].charge * self.phi_all[i]\n\n    # Break out now if no salts\n    if include_salt == False or self.use_salts == False:\n        return total_charge\n\n    for i in range(len(self.salts)):\n        total_charge += self.salts[i].charge * self.phi_salt[i]\n    return total_charge\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.laplacian","title":"<code>laplacian(array)</code>","text":"<p>Calculate the laplacian of an array pseudospectraly</p> Source code in <code>polycomp/ft_system.py</code> <pre><code>def laplacian(self, array):\n    \"\"\"\n    Calculate the laplacian of an array pseudospectraly\n    \"\"\"\n\n    # internal gradient for species on the grid\n    lap_array = self.convolve(array, -self.grid.k2)\n    return lap_array\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.map_dens_from_norm","title":"<code>map_dens_from_norm(w_like_array)</code>","text":"<p>Map any array from real density to normal representation.</p> <p>The first axis of w_like_array must be shaped like w_all's first axis.</p> <p>Parameters:</p> Name Type Description Default <code>w_like_array</code> <code>cparray</code> <p>Array in real density space to be transformed.</p> required Source code in <code>polycomp/ft_system.py</code> <pre><code>def map_dens_from_norm(self, w_like_array):\n    \"\"\"\n    Map any array from real density to normal representation.\n\n    The first axis of w_like_array must be shaped like w_all's first axis.\n\n    Parameters:\n        w_like_array (cparray):\n            Array in real density space to be transformed.\n    \"\"\"\n\n    new_array = (w_like_array.T @ (self.A_inv.T).T).T\n    return new_array\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.map_norm_from_dens","title":"<code>map_norm_from_dens(w_like_array)</code>","text":"<p>Map any array from normal to real density representation.</p> <p>The first axis of w_like_array must be shaped like w_all's first axis.</p> <p>Parameters:</p> Name Type Description Default <code>w_like_array</code> <code>cparray</code> <p>Array in normal space to be transformed.</p> required Source code in <code>polycomp/ft_system.py</code> <pre><code>def map_norm_from_dens(self, w_like_array):\n    \"\"\"\n    Map any array from normal to real density representation.\n\n    The first axis of w_like_array must be shaped like w_all's first axis.\n\n    Parameters:\n        w_like_array (cparray):\n            Array in normal space to be transformed.\n    \"\"\"\n\n    new_array2 = (w_like_array.T @ (self.A_ij)).T\n    return new_array2\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.randomize_array","title":"<code>randomize_array(array, noise)</code>","text":"<p>Generate a random array.</p> <p>Noise is Gaussian distributed around zero with a variance of noise.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>cparray</code> <p>Array used to determine the shape of the output noise.</p> required <code>noise</code> <code>float</code> <p>Variance of noise.</p> required Source code in <code>polycomp/ft_system.py</code> <pre><code>def randomize_array(self, array, noise):\n    \"\"\"\n    Generate a random array.\n\n    Noise is Gaussian distributed around zero with a variance of noise.\n\n    Parameters:\n        array (cparray):\n            Array used to determine the shape of the output noise.\n        noise (float):\n            Variance of noise.\n    \"\"\"\n    array = cp.random.random_sample(size=array.shape) * noise + 0j\n    return array\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.reduce_phi_all","title":"<code>reduce_phi_all(phi_all)</code>","text":"<p>Reduce phi_all to only the non-degenerate elements.</p> <p>Parameters:</p> Name Type Description Default <code>phi_all</code> <code>cparray</code> <p>Array like phi_all to be reduced.</p> required Source code in <code>polycomp/ft_system.py</code> <pre><code>def reduce_phi_all(self, phi_all):\n    \"\"\"\n    Reduce phi_all to only the non-degenerate elements.\n\n    Parameters:\n        phi_all (cparray):\n            Array like phi_all to be reduced.\n    \"\"\"\n\n    red_phi_all = cp.zeros(\n        [len(self.degen_dict)] + list(phi_all.shape[1:]), dtype=complex\n    )\n    for i in range(red_phi_all.shape[0]):\n        for mon in self.degen_dict[i]:\n            red_phi_all[i] += phi_all[self.monomers.index(mon)]\n    return red_phi_all\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.reindex_Q_c","title":"<code>reindex_Q_c(Q_c)</code>","text":"<p>Function to reindex Q_c to correctly handle edges of polymers.</p> <p>Because the integration takes place over the polymer beads but the values are recorded at the joints, we need to reindex the joints back to the beads. This could also be used for more complicated integration schemes later.</p> <p>Parameters:</p> Name Type Description Default <code>Q_c</code> <code>cparray</code> <p>Q_c with a shape that is associated with the joints.</p> required Source code in <code>polycomp/ft_system.py</code> <pre><code>def reindex_Q_c(self, Q_c):\n    \"\"\"\n    Function to reindex Q_c to correctly handle edges of polymers.\n\n    Because the integration takes place over the polymer beads but the\n    values are recorded at the joints, we need to reindex the joints back\n    to the beads. This could also be used for more complicated integration\n    schemes later.\n\n    Parameters:\n        Q_c (cparray):\n            Q_c with a shape that is associated with the joints.\n    \"\"\"\n\n    shape = list(Q_c.shape)\n    shape[0] -= 1\n    new_Q_c = cp.zeros(shape, dtype=complex)\n    new_Q_c += Q_c[1:] / 2 + Q_c[:-1] / 2\n\n    return new_Q_c\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.remove_degeneracy","title":"<code>remove_degeneracy(array)</code>","text":"<p>This function sums over degenerate elements.</p> <p>In the real density representation, degenerate elements should often be summed over, and this function does that.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>cparray</code> <p>Array like w_all to have degenerate elements summed over. Must be ordered the same way as w_all.</p> required Source code in <code>polycomp/ft_system.py</code> <pre><code>def remove_degeneracy(self, array):\n    \"\"\"\n    This function sums over degenerate elements.\n\n    In the real density representation, degenerate elements should often be\n    summed over, and this function does that.\n\n    Parameters:\n        array (cparray):\n            Array like w_all to have degenerate elements summed over. Must\n            be ordered the same way as w_all.\n    \"\"\"\n\n    fixed_array = cp.zeros(\n        [len(self.degen_dict)] + list(array.shape[1:]), dtype=complex\n    )\n\n    for i in range(fixed_array.shape[0]):\n        for mon in self.degen_dict[i]:\n            fixed_array[i] += array[self.monomers.index(mon)]\n    return fixed_array\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.set_monomer_order","title":"<code>set_monomer_order(monomers)</code>","text":"<p>Permanently affixes the order of the monomers.</p> <p>Orders the monomers so that solvents tend to be last and then writes them into a tuple.</p> <p>Parameters:</p> Name Type Description Default <code>monomers</code> <code>list</code> <p>List of Monomer objects to be ordered.</p> required Source code in <code>polycomp/ft_system.py</code> <pre><code>def set_monomer_order(self, monomers):\n    \"\"\"\n    Permanently affixes the order of the monomers.\n\n    Orders the monomers so that solvents tend to be last and then writes\n    them into a tuple.\n\n    Parameters:\n        monomers (list):\n            List of Monomer objects to be ordered.\n    \"\"\"\n\n    forward_count = 0\n    reverse_count = len(monomers) - 1\n    temp_list = monomers.copy()\n    for monomer in monomers:\n        if monomer.identity == \"solvent\":\n            temp_list[reverse_count] = monomer\n            reverse_count -= 1\n        else:\n            temp_list[forward_count] = monomer\n            forward_count += 1\n    self.monomers = tuple(temp_list)\n    return\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.update_density_from_normal","title":"<code>update_density_from_normal()</code>","text":"<p>Update w_all from normal_w</p> Source code in <code>polycomp/ft_system.py</code> <pre><code>def update_density_from_normal(self):\n    \"\"\"\n    Update w_all from normal_w\n    \"\"\"\n    self.w_all = self.map_dens_from_norm(self.normal_w)\n    return\n</code></pre>"},{"location":"polymersystem/#polycomp.ft_system.PolymerSystem.update_normal_from_density","title":"<code>update_normal_from_density()</code>","text":"<p>Update normal_w from w_all</p> Source code in <code>polycomp/ft_system.py</code> <pre><code>def update_normal_from_density(self):\n    \"\"\"\n    Update normal_w from w_all\n    \"\"\"\n    # update the normal mode representation to match current real\n    # represenation\n    self.normal_w = self.map_norm_from_dens(self.w_all)\n    return\n</code></pre>"}]}